\documentclass[12pt,oneside]{fithesis2}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

% Better font rendering?
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

% Examples
\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]
\newtheorem{definition}{Definition}

% Additional symbols
\usepackage{mathabx}

% Pseudo-code
\usepackage[chapter]{algorithm}
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% URL formatting
\usepackage{url}

% Diagrams
\usepackage{tikz}

% Interactive references
\usepackage{hyperref}

% ToC setup
\setcounter{tocdepth}{3}

\thesistitle{Reduced product of abstract domains}
\thesissubtitle{Bachelor thesis}
\thesisstudent{Jan Dupal}
\thesisfaculty{fi}
\thesisyear{spring 2013}
\thesisadvisor{Mgr. Karel Klíč}
\thesislang{en}

\begin{document}
\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
I would like to thank my supervisor...
\end{ThesisThanks}

\begin{ThesisAbstract}
Canal is a static analysis tool designed to analyse behaviour of application programs written in C. It is based on the theoretical framework of abstract interpretation, with focus on the scalability to large programs and proper handling of real-world source code.

Reduced product of abstract domains is a mechanism enabling an incremental evolution of abstract interpreter by introducing simple abstract domains one by one, and supporting program-specific domains. The reduced product itself is an abstract domain, and its operations (transformers) use the transformers of underlying domains component-wise. Underlying domains can improve their precision by exchanging information.

The goal of this thesis is to design and develop a generic reduced product in the context of Canal. The reduced product must provide means to exchange information between the underlying domains while keeping the domains themselves independent from each other. The impact of reduced product of integer intervals, bit field and set abstract domains on the analysis of numeric programs should be measured.
\end{ThesisAbstract}

\begin{ThesisKeyWords}
static analysis, abstract interpretation, reduced product, canal
\end{ThesisKeyWords}

\tableofcontents

\MainMatter
\chapter{Introduction}
\begin{itemize}
  \item program analysis (why?)
  \item static/dynamic
\end{itemize}

Program analysis is a field of Computer Science, which examines behaviour of programs.

\paragraph{Properties of programs}
The behaviour can be described by two distinct properties: \textit{correctness} and \textit{finiteness}.

Intuitively correctness expresses whether the program gives the same results as was intended. Formally...

Finiteness gives guarantee that program will finish it's computation in finite number of steps [citation needed].

\paragraph{Program analysis approaches}
In terms of approach program analysis is divided into two categories: dynamic and static analysis.

As the name suggests \textit{dynamic analysis} is performed on run-time. On the other hand \textit{static analysis} performed without actually executing the program. Obviously both approaches have advantages and disadvantages.

The dynamic analysis is capable of giving very precise results on given program input, where static analysis is input-independent, but it's results are more general, therefore less accurate \cite{CousotEtAl06-ASIAN}.

\section{Static program analysis}
\begin{itemize}
  \item utilization (runtime errors etc.)
  \item cons and pros
\end{itemize}

\section{Abstract interpretation}
\begin{itemize}
  \item basic principles
  \item concrete value - abstract value
\end{itemize}

When manually analysing behaviour of a given program by going through its source code, we often try to enumerate all possible values of a particular program variable. The knowledge of all possible values of the variable allow us to precisely reason about the results of expression incorporating that variable.

To correctly infer results of an expression, depending on cardinality of the expression, we take all possible combinations of input values and apply the expression. The result of our derivation is again a set of all possible values.

However, sometimes (e.g. in case of loops) the set of all possible values might be too large to memorize, so we have to resort to represent the set in another way. One option is to approximate the set as a certain property which is shared among all elements of the set. For example, a set of integers $\{1, 5, 9, 13, 17\}$ can be represented as \textit{odd integers}.

Approach to expressions evaluation is preserved -- first we \textit{concretize} the property representing the set of possible values, then we apply all possible combination of input values, resulting into a set of all possible results, which we \textit{abstract} to a property of the set.

Unconsciously we were using the concepts of \textit{abstract interpretation}.

\section{Reduced product}
\begin{itemize}
  \item References to chapters (theory)
\end{itemize}

\section{Project \textsc{Canal}}
\begin{itemize}
  \item Project goals
  \item References to chapters (implementation)
\end{itemize}


\chapter{Abstract interpretation}\label{ch:abstract-interpretation}
% \begin{itemize}
%   \item Term formalization
%   \item Theoretical frameworks
%   \item False alarms
%   \item Least fixed point
%   \item See Astre
% \end{itemize}

In some cases, a concrete question may not be answered easily. In those cases, we may resort to ask a simpler abstract question that results in an abstract answer.

Using this abstract answer we might be able to answer the original question or at least approximate the concrete answer - in that case, the abstract answer has to be sound, but not necessarily complete. \cite{CousotCousot04-WCC}

\section{Usage in static analysis}

Analogous approach has shown as successful in static program analysis, where the concrete question is whether a given program is correct, i.e. the proof of the absence of run-time errors, which is proven to be undecidable \cite{mine-AIAA10}. This problem may be solved using abstraction to soundly approximate the answer. Therefore it is necessary to formalize those abstraction, which is the goal of \textit{abstract interpretation}.

The term abstract interpretation as described in \cite{CousotCousot77-1}:

\begin{quotation}
``A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using this denotation to describe computation in another universe of abstract objects, so that the results of abstract interpretation give some information on the actual computation.''
\end{quotation}

In other words, the goal of program analysis using abstract interpretation is to provide information about program computation. The tool it uses to reach the goal is \textit{abstraction of values and operations}.

\paragraph{Abstract values}
Abstracting a set of concrete values (e.g. integers) as their property (e.g. parity) allows to represent multiple values as a single abstract value.

\paragraph{Abstract operations}
To be able to apply operation (e.g. sum of integers) on abstract values, it is necessary to define abstract operations. Abstract operations are used to transform input abstract values to output abstract values. And to be semantically correct, abstract operation must preserve the same behaviour as its concrete model regarding the property used to abstract values.

\vspace{1\baselineskip} % TODO

Given a program and the definitions of abstract values and operations, \textit{abstract interpretation} is able to interpret the program using abstract values instead of concrete values. The result of interpretation is information about properties of program values in each of program steps.


\subsection{Example}\label{sec:example}

To give a brief example of abstract values and operations consider the following computation from \cite{CousotCousot77-1}:

\[ -1515 \cdot 17 \]

To describe this computation in some abstract universe, first we need to define the domain of abstract values: symbols $(+)$ and $(-)$ to represent sign of concrete integral value and symbol $(\pm)$ for unknown sign, formally as a set $\{(+), (-), (\pm)\}$.

Using this abstract values the previous computation corresponds to the following abstract computation:

\[ -(+) \cdot (+) \Rightarrow (-) \cdot (+) \Rightarrow (-) \]

Obviously the result of the first (concrete) computation expressed as abstract value is $(-)$, which is exactly the result of the second (abstract) computation.

\paragraph{Influence of operation}
However using addition instead of multiplication ($-1515 + 17$) leads to inaccurate result of abstract computation:

\[ -(+) + (+) \Rightarrow (-) + (+) \Rightarrow (\pm) \]

As you can see, the sign of the sum of negative and positive integer might be both $+$ or $-$, depending on which component is larger in absolute value. This unknown result is in our abstract universe expressed as $(\pm)$, generally denoted as $\top$.

\paragraph{Influence of domain}
Also the choice of domain of abstract values affects accuracy of abstract computation. Choosing the domain of abstract values as $\{(even), (odd), \top\}$ to represent parity of integers instead of sign leads to the following results:

\[ -(odd) \cdot (odd) \Rightarrow (odd) \cdot (odd) \Rightarrow (odd) \]
\[ -(odd) + (odd) \Rightarrow (odd) + (odd) \Rightarrow (even) \]

The lack of $\top$ values in the results means that there was no accuracy lost when executing abstract computation.

\section{Domain of abstract values}\label{sec:domains}
% \begin{itemize}
%   \item What do abstract values represent?
%   \item Example - $+$, $-$, $\pm$, $|x|$, output
%   \item Abstract domains
%   \item False alarms
% \end{itemize}

In abstract interpretation, an abstract value denotes a set of concrete values, which is defined either explicitly or represents a set of values of certain property \cite{CousotCousot76-1}.

By convention, a domain of concrete values will further be denoted as $D$ and a domain of abstract values as $D^\#$.

\subsection{Abstraction}

The correspondence between a sets of concrete values and an abstract value is established by the \textit{abstraction function}: \cite{CousotCousot76-1}

\[
\alpha_{D^\#}\colon D \to D^\#
\]

\begin{exmp}[Abstraction, Integer Interval Domain\cite{mine-WING12}]
  \begin{gather*}
    D = \mathcal P(\mathbb Z)\\
    D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    \alpha_{D^\#}(C) \triangleq [min(C), max(C)]\\
    \alpha_{D^\#}(\{-4, 9, 11\}) = [-4, 11]\\
    \alpha_{D^\#}(\mathbb Z) = [-\infty, \infty]
  \end{gather*}
\end{exmp}

\subsection{Concretization}
Inversely to abstraction function, \textit{concretization function} is defined: \cite{CousotCousot76-1}

\[
\gamma_{D^\#}\colon D^\# \to D
\]

\begin{exmp}[Concretization, Integer Interval Domain\cite{mine-WING12}]
  \begin{gather*}
    D = \mathcal P(\mathbb Z)\\
    D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    \gamma_{D^\#}([l,h]) \triangleq \{x \in \mathbb Z | l \le x \le h\}\\
    \gamma_{D^\#}([-1,2]) = \{-1, 0, 1, 2\}\\
    \gamma_{D^\#}([-\infty, \infty]) = \mathbb Z
  \end{gather*}
\end{exmp}

\subsection{Partial order of abstract and concrete values}

We require $\langle D, \subseteq \rangle$ to be a poset, where $\subseteq$ subset relation. And dually, $\langle D^\#, \sqsubseteq \rangle$ to be also a poset, where $\sqsubseteq$ denotes \textit{information pre-order} [citation needed].

\subsection{Soundness and completeness of approximation}

\paragraph{Soundness}
In order to be sound approximation, abstraction and concretization functions has to satisfy the following requirement: \cite{mine-AIAA10}

\[
  \forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

Intuitively soundness means, that no concrete value is omitted by abstraction. In context of program analysis, soundness expresses \textit{the lack of false negatives}, which is often required property.

\paragraph{Completeness}
In opposite to soundness, \textit{completeness} is not required by abstract interpretation. But its presence is very valuable. It is defined as: \cite{mine-AIAA10}

\[
  \forall C \in D: C \supseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

Completeness corresponds in terms of static analysis to \textit{the absence of false positives}.

\subsection{Galois connection}

To set an upper bound on a ``best'' possible abstraction\cite{mine-AIAA10}, \textit{Galois connection}  between posets $(D, \subseteq)$ and $(D_\#, \sqsubseteq)$ is defined via a pair of adjoined functions $\langle \alpha_{D^\#}, \gamma_{D^\#} \rangle$ as followed: \cite{CousotCousot79-1}

\begin{enumerate}
  \item $\alpha_{D^\#}$ and $\alpha_{D^\#}$ are \textit{isotone}
  \item $\forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))$
  \item $\forall A \in D^\#: A \subseteq \alpha_{D^\#}(\gamma_{D^\#}(A))$
\end{enumerate}

Intuitively, the presence of \textit{Galois connection} ensures that any concrete value $T \in D$ has a ``best'' approximation $\alpha_{D^\#}(T)$, that over-approximates $T$ as $T \subseteq \gamma_{D^\#}(\alpha_{D^\#}(T))$. And given any other over-approximation $R \in D^\#$, so $T \subseteq \gamma_{D^\#}(R)$, then $\alpha_{D^\#}(T)$ is more precise, because $\alpha_{D^\#}(T) \sqsubseteq R$.

Galois connection also allows us to define \textit{soundness} and \textit{completeness} dually. Moreover, it also defines \textit{abstract operation} in a precise way as shown in \ref{sec:operations}.

However, the presence of Galois connection might not always be possible or feasible.

\subsection{Lattices of abstract values}

\begin{figure}[ht!]
  \centering
  \begin {tikzpicture}[node distance=1.5cm]
    \node (Top) { $\top$ };
    \node (Positive) [below left of=Top] { $(+)$ };
    \node (Negative) [below right of=Top] { $(-)$ };
    \node (Zero) [below right of=Positive] { $0$ };
    \node (Bottom) [below of=Zero] { $\bot$ };
    \draw (Top) -- (Positive);
    \draw (Top) -- (Negative);
    \draw (Positive) -- (Zero);
    \draw (Negative) -- (Zero);
    \draw (Zero) -- (Bottom);
  \end {tikzpicture}
  \caption{Sign lattice}
\end{figure}

\begin{figure}[ht!]
  \centering
  \begin {tikzpicture}[node distance=1.5cm]
    \node (Top) { $\top$ };
    \node (Even) [below left of=Top] { $ev$ };
    \node (Odd) [below right of=Top] { $od$ };
    \node (Bottom) [below right of=Even] { $\bot$ };
    \draw (Top) -- (Even);
    \draw (Top) -- (Odd);
    \draw (Even) -- (Bottom);
    \draw (Odd) -- (Bottom);
  \end {tikzpicture}
  \caption{Parity lattice}
\end{figure}

\section{Abstract operations}\label{sec:operations}

As stated in the introduction, abstract operation (sometimes referred as \textit{abstract transformers}) enable to approximate results of transformations defined in programs. To preserve soundness of abstract interpretation, abstract operations also has to be sound as defined in section \ref{sec:operations-soundness}.

\subsection{Sound definition}\label{sec:operations-soundness}

For any concrete $n$-ary primitive $F: D^n \to D$, in case of Galois connection a ``best'' possible abstraction $F_{D^\#}$ is defined: \cite{mine-AIAA10}

\[
  F_{D^\#} \triangleq \alpha_{D^\#} \circ F \circ \gamma_{D^\#}
\]

Otherwise, $F_{D^\#}$ over-approximates $F$. Therefore, we require $F_{D^\#}$ to be a sound abstraction: \cite{CousotEtAl06-ASIAN}

\[
\forall a_i \in D^\#: F_{D^\#}((\gamma_{D^\#}(a_i))_{1 \le i \le n}) \subseteq \gamma_{D^\#}(F((a_i)_{1 \le i \le n}))
\]

\subsection{Example}

\begin{exmp}[Addition, Integer Interval Domain\cite{mine-WING12}]
  \begin{align*}
    &D = \mathcal P(\mathbb Z)\\
    &D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &F: D \times D \to D\\
    &F(A,B) \triangleq \{a+b | a \in A, b \in B \}\\
    &F_{D^\#}: D^\# \times D^\# \to D^\#\\
    &F_{D^\#}([l_1, h_1], [l_2, h_2]) \triangleq [l_1 + l_2, h_1 + h_2]\\
    &F(\{1,2,3\}, \{0,10\}) = \{1,2,3,11,12,13\}\\
    &F_{D^\#}([1,3], [0,10]) = [1,13]
  \end{align*}
\end{exmp}

\chapter{Reduced product}

As demonstrated in Example in section \ref{sec:example}, a single abstract domain may not be able to accurately cover all possible abstract operations. Therefore it is convenient to incorporate \textit{multiple specialized abstract domains}. Each of these domains may capture a specific property of concrete value while ignoring other [citation].

When designing a new abstract domain, this approach allows us to focus on the core functionality of the domain and does not burden us with necessity of implementing all possible abstract operations in accurate manner, which may not be possible or feasible. But it ultimately leads to the need for inter-domain accuracy refinements.

This chapter establishes \textit{domain product} in section \ref{sec:domain-product}, which is later in section \ref{sec:reduced-cardinality-product} extended into \textit{reduced cardinality product} using appropriate \textit{reduction} defined in section \ref{sec:reductions}.

The chapter is concluded by a proposal of implementation in section \ref{sec:proposal-of-implementation}.

% From high-level view the goal of the communication framework is to encapsulate and refine abstract domains representing a single program variable, hence it can be viewed as a \textit{reduced product of abstract domains}.

% Reduced product of abstract domains consist of the following components:

% \begin{description}
%   \item[Domain product] encapsulates multiple abstract values
%   \item[Communication protocol] enables inter-domain communication
%   \item[Internal structure] defines process of refinement
% \end{description}

\section{Domain product}\label{sec:domain-product}
% \begin{itemize}
%   \item Definition
%   \item Multiple representations of concrete value
% \end{itemize}

Motivation to introduce \textit{domain product} to abstract interpretation has been outlined in the beginning of this chapter - using a single abstract value to represent a program value would lead either to inaccurate results or complex implementation. Also it would not allow to deploy a new abstract domain tailored for a specific problem. \cite{CousotEtAl06-ASIAN}

To circumvent this obstacle, it is convenient to introduce a \textit{domain product}, which acts as encapsulation of abstract values representing the same program variable. From an external perspective, the domain products performs as a standalone abstract domain.

\textit{Domain product} is defined as follows \cite{CousotCousotMauborgne-FoSSaCS-11}:

\begin{definition}
  Let $\langle D^\#_i, \sqsubseteq_i \rangle$, $i \in I$, $I$ finite, be abstract domains. Their Cartesian product is $\langle D^\#, \sqsubseteq \rangle$, where:
  \begin{align*}
    &D^\# \triangleq \bigtimes_{i \in I} D^\#_i\\
    &P \sqsubseteq Q \triangleq \bigwedge_{i \in I}\left(P_i \sqsubseteq_i Q_i \right)\\
    &\gamma_{D^\#}: \bigtimes_{i \in I} D^\#_i \to D\\
    &\gamma_{D^\#}(P) \triangleq \bigcap_{i \in I} \gamma_{D^\#_i}\left( P_i \right)
  \end{align*}
\end{definition}

To approach the definition, consider the following example.

\begin{exmp}
  \begin{align*}
    &D = D_1 = D_2 = \mathcal P(\mathbb Z)\\
    &D^\#_1 = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &D^\#_2 = \{\bot, ev, od, \top\}\\
    &D^\# = D^\#_1 \times D^\#_2\\
    &\alpha_{D^\#}(\{1,3,7\}) = \left( [1,7], od \right)\\
    &\gamma_{D^\#}(\left( [1, 7], od \right)) = \{1,3,5,7\}
  \end{align*}

  By the definition, $\left( [1, 7], od \right) \sqsubseteq \left( [0, 7], \top \right)$, however $\left( [1, 7], od \right) \not\sqsubseteq \left( [1, 7], ev \right)$.
\end{exmp}

As it may seem that $\gamma_{D^\#}$ provides the key to refinement of abstract values, we have to keep in mind that abstract functions are still applied component-wise. Therefore we get the same results as in case of \textit{separate analyses}, as stated in \cite{CousotCousot79-1}.

\section{Reduced product}\label{sec:reduced-cardinality-product}

As \textit{domain product} contains multiple abstract domains, each covering different aspect of concrete value, we may increase accuracy of contained domains by exploiting inter-domain refinements.

Intuitively, if one of the domains has inaccurately approximated a result of some concrete operation, while other domain was able to give an accurate abstraction, it would be convenient to enhance accuracy of the first domain using information provided by the second domain. Obviously the degree of improvement depends on the difference in the nature of abstraction used by domains.

\paragraph{Soundness} To preserve soundness of analysis, a reduction of domain product has to keep its semantics -- a concrete value it represents has to remain unchanged.

\textit{Reduced product} is defined in the following way: \cite{CousotCousotMauborgne-FoSSaCS-11}

\begin{definition}
  Let $\langle D^\#, \sqsubseteq \rangle$ be a \textit{domain product} with concretization function $\gamma_{D^\#}$.

  Then \textit{reduced product} is $\langle D^\# /_\equiv, \sqsubseteq \rangle$, where equivalence is defined as  $\left(P \equiv Q \right) \triangleq \left(\gamma_{D^\#}(P) = \gamma_{D^\#}(Q) \right)$ and $\gamma_{D^\#}$ as well as $\sqsubseteq$ are naturally extended to the equivalence class $[P]/_\equiv$, $P \in D^\#$, of $\equiv$.
\end{definition}

\section{Approximations of reduction}\label{sec:reductions}

\section{Proposal of implementation}\label{sec:proposal-of-implementation}

\subsection{Communication protocol}
\begin{itemize}
  \item Types of communication (direct, broadcast)
  \item Description of message
  \item Properties of message (lattice)
  % \item Extract
  % \item Refine
\end{itemize}

\subsection{Extract operation}

Extract operation applied on a given abstract value results into message containing refinement information.

\subsection{Refine operation}

Refine operation attempts to improve accuracy of abstract value using refinement information from refinement message.

\subsection{Internal structure}
\begin{itemize}
  \item Plain and Tree
  \item Traversing algorithms
  \item Expected impact on accuracy and performance
  \item Correctness, convergence, complexity
\end{itemize}


\chapter{Implementation in \textsc{Canal}}
% \begin{itemize}
%   \item Overview of Canal
%   \item Overview of RP implementation
% \end{itemize}

This chapter addresses \textsc{Canal} project and its implementation of \textit{reduced product}.

\section{Introduction to \textsc{Canal} project}

\textsc{Canal} is a static analysis tool designed to analyze behaviour of
application programs written in C [language]. It is based on the theoretical
framework of abstract interpretation, with focus on the scalability to
large programs and proper handling of real-world source code. \cite{Canal}

It consists of three main components:

\begin{description}
  \item[Abstract domains] set of predefined abstract domains to cover machine integers, floating point numbers, arrays and structures
  \item[Interpreter] component responsible for source code traversal and program state management
  \item[Operations] translation from program instructions to operations on abstract values
\end{description}

Components \textit{abstract domains} and \textit{operations} correspond to entities described in chapter \ref{ch:abstract-interpretation}. \textit{Interpreter} involves concept of \textit{least fixed point} (section \ref{sec:fixed-point}) and it is interesting from technical point of view, because it incorporates LLVM libraries for interaction with source code.

LLVM is a a compiler framework, which provides a combination of key capabilities that are important for practical, lifelong analysis and
transformation of programs. \cite{llvm} It isolates \textsc{Canal} from machine-level semantics of C language and allows to offload processes associated with compiling and instruction-level analysis, therefore development of \textsc{Canal} can fully focus on abstract interpretation.

Provided the previous components, \textsc{Canal} is able to statically analyze general programs written in C. The high-level work flow can be described in the following way:

\begin{enumerate}
  \item Compilation of program source utilising LLVM compiler
  \item Load of resulting LLVM bytecode
  \item Initialization of program state using abstract values
  \item Translation of program instructions to abstract operations
  \item Execution of abstract operations on abstract values
\end{enumerate}

\section{Framework of reduced product in \textsc{Canal}}

\subsection{Containers}
\begin{itemize}
  \item Vector, Tree
  \item Cons and pros
\end{itemize}

\subsection{Messages}
\begin{itemize}
  \item Kind of messages
  \item Meet
\end{itemize}

\subsection{Extract and Refine operations}
\begin{itemize}
  \item Design of extract/refine operations
\end{itemize}

\section{Integer reduced product}
\begin{itemize}
  \item Walkthrough of Integer domain RP implementation
\end{itemize}


\chapter{Measurements}
\begin{itemize}
  \item Accuracy
  \item Performance
\end{itemize}
\section{Artificial programs analysis}
\section{\textsc{GNU Core Utilities} analysis}


\chapter{Conclusion}
\section{Impact on program analysis}
\section{Future work}
\begin{itemize}
  \item Pre-condition refinements
  \item Task-parallelism, topological order
\end{itemize}

\bibliographystyle{plain}
\bibliography{reduced_product}

\end{document}