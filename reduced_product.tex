\documentclass[12pt,oneside]{fithesis2}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

% Better font rendering?
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

% Examples
\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]
\newtheorem{definition}{Definition}

% Additional symbols
\usepackage{mathabx}

% Pseudo-code
\usepackage[chapter]{algorithm}
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% URL formatting
\usepackage{url}

% Diagrams
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}

% Interactive references
\usepackage{hyperref}

% ToC setup
\usepackage[nottoc,numbib]{tocbibind}
\setcounter{tocdepth}{3}

\thesistitle{Reduced product of abstract domains}
\thesissubtitle{Bachelor thesis}
\thesisstudent{Jan Dupal}
\thesisfaculty{fi}
\thesisyear{spring 2013}
\thesisadvisor{Mgr. Karel Klíč}
\thesislang{en}

\begin{document}
\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
I would like to thank my supervisor...
\end{ThesisThanks}

\begin{ThesisAbstract}
Canal is a static analysis tool designed to analyse behaviour of application programs written in C. It is based on the theoretical framework of abstract interpretation, with focus on the scalability to large programs and proper handling of real-world source code.

Reduced product of abstract domains is a mechanism enabling an incremental evolution of abstract interpreter by introducing simple abstract domains one by one, and supporting program-specific domains. The reduced product itself is an abstract domain, and its operations (transformers) use the transformers of underlying domains component-wise. Underlying domains can improve their precision by exchanging information.

The goal of this thesis was to design and develop a generic reduced product in the context of Canal. The reduced product provides means to exchange information between the underlying domains while keeping the domains themselves independent from each other. The impact of reduced product of integer intervals, bit field and set abstract domains on the analysis of programs is measured.
\end{ThesisAbstract}

\begin{ThesisKeyWords}
static analysis, abstract interpretation, reduced product, canal
\end{ThesisKeyWords}

\tableofcontents

\MainMatter
\chapter{Introduction}
% \begin{itemize}
%   \item program analysis (why?)
%   \item static/dynamic
% \end{itemize}

The more software we employ into the products we use on daily basis, the more we become dependent on the \textit{reliability} of these products. Reliability represents how much we trust in the fact that a given product will not fail in fulfilling its purpose.

The well known saying, that \textit{a chain is only as strong as its weakest link}, is in the case of products incorporating software doubly true -- no matter how well the product is physically manufactured, if the software fails, the whole product fails.

The severity of a potential failure may span from inconvenience in case of non-critical appliances (an inoperable coffee machine) to very serious aftermaths -- life-threatening and costly malfunctions of software used for example in health care or aerospace industry. Naturally, the most effective way to reduce impacts of software failures is to \textit{prevent their occurrences} preferably right at their origins -- in source codes of computer programs.

Especially in mission critical applications, a single unnoticed software bug might destroy a value of unimaginable magnitude. Therefore it is logical to demand tools to help proving the lack of bugs.

\textit{Program analysis} is a field of computer science, which examines behaviour of programs. The behaviour of programs can be analysed in many ways, one of them is \textit{static analysis} via \textit{abstract interpretation}. In this context the word static means ``without executing the program'', while abstract interpretation represents a technique of approximating program values and operations using abstractions as a base concept.

The goal of this thesis is to design and implement a \textit{reduced product of abstract domains} framework for open-source abstract interpretation tool \textsc{Canal}. The framework improves accuracy of analysis by allowing information exchange between contained \textit{abstract domains}.

The \hyperref[ch:abstract-interpretation]{first chapter} summarizes a theoretical framework of \textit{abstract interpretation} in context of static analysis to provide a solid foundation to introduce \texttt{reduced product} in the \hyperref[ch:reduced-product]{second chapter}. The \hyperref[ch:implementation]{third chapter} discusses the actual design and describes the implementation in \textsc{Canal}, which effectiveness and efficiency is measured in the \hyperref[ch:measurements]{last chapter} on a set of programs from \textsc{GNU Coreutils}.

\chapter{Abstract interpretation}\label{ch:abstract-interpretation}
% \begin{itemize}
%   \item Term formalization
%   \item Theoretical frameworks
%   \item False alarms
%   \item Least fixed point
%   \item See Astre
% \end{itemize}

In some cases, a concrete question may not be answered easily. In those cases, we may resort to ask a simpler abstract question that results in an abstract answer.

Using this abstract answer we might be able to answer the original question or at least approximate the concrete answer. \cite{CousotCousot04-WCC}

\section{Usage in static analysis}

Analogous approach has shown as successful in static program analysis, where the concrete question is whether a given program is correct, i.e. the proof of the absence of run-time errors, which is proven to be undecidable \cite{mine-AIAA10}. This problem may be solved using abstraction to soundly approximate the answer. Therefore it is necessary to formalize those abstraction, which is the goal of \textit{abstract interpretation}.

The term abstract interpretation as described in \cite{CousotCousot77-1}:

\begin{quotation}
``A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using this denotation to describe computation in another universe of abstract objects, so that the results of abstract interpretation give some information on the actual computation.''
\end{quotation}

In other words, the goal of program analysis using abstract interpretation is to provide information about program computation. The tool it uses to reach the goal is \textit{abstraction of values and operations}.

\paragraph{Concrete value}
A concrete value stands for a program value during execution. E.g. number 5 is a concrete value of an integer variable in some execution of a program.

\paragraph{Abstract value}
An abstract value represents a set of concrete values of a given property (e.g. parity), depending on particular definition. This abstractions allows us to approximate results of concrete executions.

\paragraph{Abstract operations}
To be able to apply operation (e.g. sum of integers) on abstract values, it is necessary to define abstract operations. Abstract operations are used to transform input abstract values to output abstract values. To be semantically correct, abstract operation must preserve the same behaviour as its concrete model regarding the property used to abstract values.

\vspace{1\baselineskip} % TODO

Given a program and the definitions of abstract values and operations, \textit{abstract interpretation} is able to interpret the program using abstract values instead of concrete values. The result of interpretation is information about properties of program values in each of program steps.


\subsection{Example}\label{sec:example}

To give a brief example of abstract values and operations consider the following computation from \cite{CousotCousot77-1}:

\[ -1515 \cdot 17 \]

To describe this concrete computation as an abstract computation, first we need to define abstract values: symbols $(+)$ and $(-)$ to represent sign of concrete integral value and symbol $(\pm)$ for unknown sign.

Using this abstract values the previous computation corresponds to the following abstract computation:

\[ -(+) \cdot (+) \Rightarrow (-) \cdot (+) \Rightarrow (-) \]

Obviously the result of the first (concrete) computation expressed as abstract value is $(-)$, which is exactly the result of the second (abstract) computation.

\paragraph{Influence of operation}
However using addition instead of multiplication ($-1515 + 17$) leads to inaccurate result of abstract computation:

\[ -(+) + (+) \Rightarrow (-) + (+) \Rightarrow (\pm) \]

As you can see, the sign of the sum of negative and positive integer might be both $+$ or $-$, depending on which component is larger in absolute value. This unknown result is in our abstract universe expressed as $(\pm)$, generally denoted as $\top$.

\paragraph{Influence of abstraction}
Also the choice of abstract values affects accuracy of abstract computation. Choosing abstract values as $\{(even), (odd), \top\}$ to represent parity of integers instead of sign leads to the following results:

\[ -(odd) \cdot (odd) \Rightarrow (odd) \cdot (odd) \Rightarrow (odd) \]
\[ -(odd) + (odd) \Rightarrow (odd) + (odd) \Rightarrow (even) \]

The lack of $\top$ values in the results means that there was no accuracy lost when executing abstract computation.

\section{Theoretical framework}
% \begin{itemize}
%   \item What do abstract values represent?
%   \item Example - $+$, $-$, $\pm$, $|x|$, output
%   \item Abstract domains
%   \item False alarms
% \end{itemize}

This section describes formal requirements necessary to correctly design and implement an abstract interpretation framework including \textit{reduced product}.

\subsection{Domain of abstract values}

As abstract value represents a set of concrete values, so their domains preserve the same relation. \textit{Domain of abstract values} represents a set of all \textit{abstract values} and \textit{domain of concrete values} corresponds to a power set of all concrete values.

For easier comprehension, regard the following definition of \textit{integer interval domain}\cite{mine-WING12}, on which we will demonstrate the usage of defined terms in this chapter.

\textit{Integer interval domain} approximates a set of integers by a pair $[l, h]$, where $l$ and $h$ represents minimal and maximal element of the set, respectively. For example:

\[
  \{ 2, 1, 100, 4 \} \to [1, 100]
\]

As it can be seen, a set of integers $\{2, 1, 100, 4\}$ is represented by integer interval domain as a pair $[1, 100]$. This so called \textit{abstraction function} is later formalized in \ref{ssec:abstraction-function}.

Formal definition of domains used in the \textit{integer interval domain} follows:

\begin{exmp}
  \begin{align*}
    &D = \mathcal P(\mathbb Z)\\
    &D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
  \end{align*}
\end{exmp}

The \textit{domain of concrete values} $D$, in the case of integers, is a power set of integers $\mathbb Z$. To remind, a concrete value denotes any program value and their set describes all possible values of a given program value.

And the \textit{domain of abstract values} $D^\#$ is defined to approximate sets of concrete values from $D$. In this case, it is a set of all pairs $[l, h]$, where $l$ and $h$ are integers or symbols representing positive or negative infinity.

This abstraction was chosen, because it is useful for many kinds of numerical computation analyses\cite{mine-AIAA10} and its underlying concepts are easy to understand.

By convention, a domain of concrete values will further be denoted as $D$ and a domain of abstract values as $D^\#$ and their elements as $a$ and $C$ respectively.

\subsection{Abstraction function}\label{ssec:abstraction-function}

The correspondence between sets of concrete values and abstract values is established by the \textit{abstraction function} \cite{CousotCousot76-1}:

\[
\alpha_{D^\#}\colon D \to D^\#
\]

The \textit{abstraction function} assigns an abstract value to a given set of concrete values. It belongs to the core concepts of the abstract interpretation, because it provides a bridge between program values and their abstractions -- every program value has to be abstracted before proceeding with abstract interpretation of the program.

To give a particular \textit{abstraction function}, consider the one used in integer interval domain:

\begin{exmp}
  \begin{align*}
    % D = \mathcal P(\mathbb Z)\\
    % D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &\alpha_{D^\#}(C) \triangleq [min(C), max(C)]\\
    &\alpha_{D^\#}(\{-1, 0, 3\}) = [-1, 3]\\
    &\alpha_{D^\#}(\mathbb Z) = [-\infty, \infty]
  \end{align*}
\end{exmp}

As it was outlined in the introduction to this section, the \textit{integer interval domain} represents sets of concrete values as a pair of minimal and maximal element -- the bounds of the interval.

The example demonstrates application of \textit{abstraction function} $\alpha_{D^\#}$ on a small set of integers, which is rather obvious. And the second application shows interval $[-\infty, \infty]$ corresponding to the set of all integers, $\mathbb Z$.

Note that this particular abstraction may include in the approximation some excessive concrete values due to its definition utilizing only minimal and maximal element -- this property of abstraction is denoted as \textit{incompleteness} and will be defined later in \ref{ssec:soundness-incompleteness}.

\subsection{Concretization function}
Dually to the abstraction function, \textit{concretization function} transforms an abstract value into a set of concrete values, which are represented by the given abstract value.

Importance of this function lies in the fact that it defines a concrete semantics of abstract values -- it enables us to translate results of abstract interpretation into the universe of concrete values. Together with abstract functions, it defines almost all subsequent terms of abstract interpretation.

A \textit{concretization function} is a function of type:

\[
\gamma_{D^\#}\colon D^\# \to D
\]

One example is the concretization function of the \textit{integer interval domain}:

\begin{exmp}
  \begin{align*}
    % D = \mathcal P(\mathbb Z)\\
    % D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &\gamma_{D^\#}([l,h]) \triangleq \{x \in \mathbb Z | l \le x \le h\}\\
    &\gamma_{D^\#}([-1,3]) = \{-1, 0, 1, 2, 3\}\\
    &\gamma_{D^\#}([-\infty, \infty]) = \mathbb Z
  \end{align*}
\end{exmp}

Concretization function of the integer interval domain converts an interval into a set of all integers lying between the bounds of the interval, including the bounds.

As you can see, this concretization function does not omit any of the concrete values inside the interval, thanks of the definition, which over-approximates the set of concrete values, thus giving guarantee on \textit{soundness} -- this property is formalized in \ref{ssec:soundness-incompleteness}.

\subsection{Partial order of abstract and concrete values}

Since the domain of concrete values is defined as a power set, it can be partially ordered by set inclusion $\subseteq$. This property is interesting to abstract interpretation, because it allows to compare sets of abstract values in the sense of ``is included in'', which is a useful feature e.g. when computing a fixed point of a given loop in a program.

Dually we define partial order on the domain of abstract values via $\sqsubseteq$ also expressing ``is included in''. Again, this relation enables us to compare abstract values and e.g. compute abstract fix point of a loop or of a complete program.

Generally the $\sqsubseteq$ is defined as follows:

\begin{definition}
  Let $A_1, A_2 \in D^\#$, then
  \[
    A_1 \sqsubseteq A_2 \triangleq \gamma_{D^\#}(A_1) \subseteq \gamma_{D^\#}(A_2)
  \]
\end{definition}


The following demonstration shows definition of $\sqsubseteq$ and a link between $\subseteq$ and $\sqsubseteq$ in the integer interval domain:

\begin{exmp}
  \begin{align*}
    [l_1, h_1] \sqsubseteq [l_2, h_2] &\triangleq l_1 \ge l_2 \wedge h_1 \le h_2\\
    \emptyset \subseteq \{1\} &\subseteq \{0, 1, 2\} \subseteq \mathbb Z\\
    [1,0] \sqsubseteq [1,1] &\sqsubseteq [0,2] \sqsubseteq [-\infty,\infty]
  \end{align*}
\end{exmp}

As it can be seen, if the sets of concrete values do not omit any value between minimal and maximal element, operators $\subseteq$ and $\sqsubseteq$ correspond precisely. However, if the set of concrete values does not cover the whole range, $\not\subseteq$ may not imply $\not\sqsubseteq$ -- observe the following example:

\begin{exmp}
  \begin{align*}
    \{0, 7\} \not\subseteq \{4, 5\} &\Rightarrow [0,7] \not\sqsubseteq [4,5]\\
    \{ 4, 5\} \not\subseteq \{0, 7\} &\not\Rightarrow [4,5] \not\sqsubseteq [0,7]\\
  \end{align*}
\end{exmp}

While the first case in the last example confirms the implication, the second serves as a counterexample. This example demonstrates the consequences of using approximations in static analysis, a deeper insight into properties of approximation is provided by section \ref{ssec:soundness-incompleteness}.

Using partial order defined by $\sqsubseteq$ and defining $\bot$ and $\top$ as minimal and maximal elements of the set $D^\#$, we are able to construct a lattice of abstract values.

\begin{figure}[ht!]
  \centering
  \begin {tikzpicture}[on grid]
    % nodes
    \node (bot) at (0,-1) { $\bot$ };

    \node (-3_-3) at (-6,1) {};
    \node (-2_-2) at (-4,1) { $[-2, -2]$ };
    \node (-1_-1) at (-2,1) { $[-1, -1]$ };
    \node (0_0) at (0,1) { $[0, 0]$ };
    \node (1_1) at (2,1) { $[1, 1]$ };
    \node (2_2) at (4,1) { $[2, 2]$ };
    \node (3_3) at (6,1) {};

    \node (-3_-2) at (-5,2) {};
    \node (-2_-1) at (-3,2) { $[-2, -1]$ };
    \node (-1_0) at (-1,2) { $[-1, 0]$ };
    \node (0_1) at (1,2) { $[0, 1]$ };
    \node (1_2) at (3,2) { $[1, 2]$ };
    \node (2_3) at (5,2) {};

    \node (-3_-1) at (-4,3) {};
    \node (-2_0) at (-2,3) { $[-2, 0]$ };
    \node (-1_1) at (0,3) { $[-1, 1]$ };
    \node (0_2) at (2,3) { $[0, 2]$ };
    \node (1_3) at (4,3) {};

    \node (-3_0) at (-3,4) {};
    \node (-2_1) at (-1,4) { $[-2, 1]$ };
    \node (-1_2) at (1,4) { $[-1, 2]$ };
    \node (0_3) at (3,4) {};

    \node (-3_1) at (-2,5) {};
    \node (-2_2) at (0,5) { $[-2, 2]$ };
    \node (-1_3) at (2,5) {};

    \node (-3_2) at (-1,6) {};
    \node (-2_3) at (1,6) {};

    \node (top) at (0,8) { $\top$ };
    \node (subt0) at (-4, 6.5) {};
    \node (subt1) at (-2, 6.5) {};
    \node (subt2) at (0, 6.5) {};
    \node (subt3) at (2, 6.5) {};
    \node (subt4) at (4, 6.5) {};

    % lines
    \draw[dashed] ($(bot) !.5! (-3_-3) $) -- ($(bot) !.9! (-3_-3) $);
    \draw         (bot) -- ($(bot) !.5! (-3_-3) $);
    \draw         (bot) -- (-2_-2);
    \draw         (bot) -- (-1_-1);
    \draw         (bot) -- (0_0);
    \draw         (bot) -- (1_1);
    \draw         (bot) -- (2_2);
    \draw         (bot) -- ($(bot) !.5! (3_3) $);
    \draw[dashed] ($(bot) !.5! (3_3) $) -- ($(bot) !.9! (3_3) $);

    \draw[dashed] (-2_-2) -- ($(-2_-2) !.8! (-3_-2) $);
    \draw         (-2_-2) -- (-2_-1);
    \draw         (-1_-1) -- (-2_-1);
    \draw         (-1_-1) -- (-1_0);
    \draw         (0_0)   -- (-1_0);
    \draw         (0_0)   -- (0_1);
    \draw         (1_1)   -- (0_1);
    \draw         (1_1)   -- (1_2);
    \draw         (2_2)   -- (1_2);
    \draw[dashed] (2_2)   -- ($(2_2) !.8! (2_3) $);

    \draw[dashed] (-2_-1) -- ($(-2_-1) !.8! (-3_-1) $);
    \draw         (-2_-1) -- (-2_0);
    \draw         (-1_0)  -- (-2_0);
    \draw         (-1_0)  -- (-1_1);
    \draw         (0_1)   -- (-1_1);
    \draw         (0_1)   -- (0_2);
    \draw         (1_2)   -- (0_2);
    \draw[dashed] (1_2)   -- ($(1_2) !.8! (1_3) $);

    \draw[dashed] (-2_0) -- ($(-2_0) !.8! (-3_0) $);
    \draw         (-2_0) -- (-2_1);
    \draw         (-1_1) -- (-2_1);
    \draw         (-1_1) -- (-1_2);
    \draw         (0_2)  -- (-1_2);
    \draw[dashed] (0_2) -- ($(0_2) !.8! (0_3) $);

    \draw[dashed] (-2_1) -- ($(-2_1) !.8! (-3_1) $);
    \draw         (-2_1) -- (-2_2);
    \draw         (-1_2) -- (-2_2);
    \draw[dashed] (-1_2) -- ($(-1_2) !.8! (-1_3) $);

    \draw[dashed] (-2_2) -- ($(-2_2) !.8! (-3_2) $);
    \draw[dashed] (-2_2) -- ($(-2_2) !.8! (-2_3) $);

    \draw[dashed] (top) -- ($(top) !.66! (subt0) $);
    \draw[dashed] ($(top) !.5! (subt1) $) -- (subt1);
    \draw         (top) -- ($(top) !.5! (subt1) $);
    \draw[dashed] ($(top) !.5! (subt2) $) -- (subt2);
    \draw         (top) -- ($(top) !.5! (subt2) $);
    \draw[dashed] ($(top) !.5! (subt3) $) -- (subt3);
    \draw         (top) -- ($(top) !.5! (subt3) $);
    \draw[dashed] (top) -- ($(top) !.66! (subt4) $);
  \end {tikzpicture}
  \caption{Lattice of integer interval domain}
  \label{fig:interval-lattice}
\end{figure}

The figure \ref{fig:interval-lattice} show a part of infinite lattice of the integer interval abstract domain. The edges correspond to $\sqsubseteq$ relation except for transitivity. As it can be seen, the lowest level represents an abstract value corresponding to an empty set. One level higher are placed intervals standing for sets of length one and edges connect them to intervals in upper level while expressing ``is included in'' relation.

% \begin{figure}[ht!]
%   \centering
%   \begin {tikzpicture}[node distance=1.5cm]
%     \node (Top) { $\top$ };
%     \node (Even) [below left=of Top] { $ev$ };
%     \node (Odd) [below right=of Top] { $od$ };
%     \node (Bottom) [below right=of Even] { $\bot$ };
%     \draw (Top) -- (Even);
%     \draw (Top) -- (Odd);
%     \draw (Even) -- (Bottom);
%     \draw (Odd) -- (Bottom);
%   \end {tikzpicture}
%   \caption{Lattice of parity domain}
% \end{figure}

\subsection{Correctness of approximation}\label{ssec:soundness-incompleteness}

If we want to gain informative results via a program analysis, we have to ensure that the analysis is \textit{correct}. Correctness consists of three distinct properties: \textit{soundness}, \textit{completeness} and \textit{termination}.

\paragraph{Soundness}
Soundness expresses, that a given abstraction do include every case having a particular property, but since it is an over-approximation, some of those cases might not occur in the reality.

In order to be sound analysis, the abstraction and concretization functions has to satisfy the following requirement \cite{mine-AIAA10}:

\[
  \forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

Intuitively soundness means, that no concrete value is omitted by abstraction. In the context of program analysis, soundness represents the \textit{lack of false negatives}, which is often required property.

For example, when analysing a program and there is a \textit{possibility} of zero division occurrence, sound analysis has to report this fact.

The proof of soundness of integer interval domain is as follows:

\begin{proof}
  Let $D$, $D^\#$, $\alpha_{D^\#}$ and $\gamma_{D^\#}$ be defined as in the integer interval domain. We want to prove:
  \[
    \forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
  \]
  Via definition:
  \begin{align*}
    \gamma_{D^\#}(\alpha_{D^\#}(C)) &= \gamma_{D^\#}([min(C), max(C)])\\
    &= \{ x \in \mathbb Z | min(C) \le x \le max(C) \}
  \end{align*}
  When substituted into the original expression:
  \[
    \forall C \in \mathcal P(\mathbb Z): C \subseteq \{ x \in \mathbb Z | min(C) \le x \le max(C) \}
  \]
  Which proves soundness of the integer interval domain.
\end{proof}

\paragraph{Completeness}
Dually to soundness, completeness represent guarantee that any statement proved in abstract is also valid in concrete \cite{mine-AIAA10}, which means that a statement derived from abstraction is truthful for every individual concrete case.

Completeness requires the following \cite{mine-AIAA10}:

\[
  \forall C \in D: C \supseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

In the context of abstract analysis, completeness corresponds to the \textit{absence of false positives}. For example, false positive result is case when program analysis reports zero division, while it is not possible to occur.

Since abstract interpretation does not require completeness (reason will be given later), it might not be present as we can prove in case of the integer interval domain:

\begin{proof}
  Let $D$, $D^\#$, $\alpha_{D^\#}$ and $\gamma_{D^\#}$ be defined as in the integer interval domain. We want to refute:
  \[
    \forall C \in D: C \supseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
  \]
  We will use counterexample $C = \{1, 3\}$:
  \begin{align*}
    \gamma_{D^\#}(\alpha_{D^\#}(\{1, 3\})) &= \gamma_{D^\#}([1, 3])\\
    &= \{1, 2, 3\}
  \end{align*}
  Obviously:
  \[
    \{1, 3\} \not\supseteq \{1, 2, 3\}
  \]
  Which proves \textit{incompleteness} of the integer interval domain.
\end{proof}

\paragraph{Termination} Termination is also very important property of a program analysis. However, termination is mainly matter of fix point computation, which is not the topic of this thesis. Details can be found in \cite{CousotCousot79-1}.

To conclude this section, abstract interpretation requires \textit{soundness} and \textit{termination}, while \textit{completeness} is not achievable as in case of all sound formal methods \cite{CousotEtAl06-ASIAN}.

\subsection{Galois connection}

When designing an abstract interpretation framework, one of methods shown in \cite{CousotCousot92-2} is via defining \textit{Galois connection} as introduced in \cite{CousotCousot76-1}. Galois connection puts constraints on abstraction and concretization function in exchange of interesting properties, e.g. ``best'' approximation, which will be described later in this section.

Galois connection is defined via a pair of adjoined functions $\langle \alpha_{D^\#}, \gamma_{D^\#} \rangle$ as followed: \cite{CousotCousot79-1}

\begin{definition}
  Let $\langle D, \subseteq \rangle$, $\langle D^\#, \sqsubseteq \rangle$ be posets and $\alpha_{D^\#}$, $\gamma_{D^\#}$ abstraction and concretization functions respectively.

  A pair $\langle \alpha_{D^\#}, \gamma_{D^\#} \rangle$ defines Galois connection if the following criteria are met.
  \begin{enumerate}
    \item $\alpha_{D^\#}$ and $\alpha_{D^\#}$ are \textit{isotone}, in terms of $\subseteq$ and $\sqsubseteq$
    \item $\forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))$
    \item $\forall a \in D^\#: a \subseteq \alpha_{D^\#}(\gamma_{D^\#}(a))$
  \end{enumerate}
\end{definition}

Intuitively, the presence of \textit{Galois connection} ensures that any concrete value $T \in D$ has a ``best'' approximation $\alpha_{D^\#}(T)$, that over-approximates $T$ as $T \subseteq \gamma_{D^\#}(\alpha_{D^\#}(T))$. And given any other over-approximation $R \in D^\#$, so $T \subseteq \gamma_{D^\#}(R)$, then $\alpha_{D^\#}(T)$ is more precise, because $\alpha_{D^\#}(T) \sqsubseteq R$.

% TODO draw a diagram representing GC

Galois connection also allows us to define \textit{soundness} and \textit{completeness} dually (via abstract values instead of concrete values). Moreover, it also defines \textit{abstract operation} in a precise way as shown in \ref{sec:operations}.

\subsection{Abstract operations}\label{sec:operations}

As stated in the introduction, abstract operation (sometimes referred as \textit{abstract transformers}) enable to approximate results of transformations defined in programs.

In case of Galois connection, abstract operations are precisely defined, because we can exploit properties of abstraction and concretization functions.

\begin{definition}\label{def:operation-galois}
  For any concrete $n$-ary primitive $F: C^n \to C$, where $C \in D$, abstract operation $F_{D^\#}$ is defined: \cite{mine-AIAA10}

  \[
    F_{D^\#} \triangleq \alpha_{D^\#} \circ F \circ \gamma_{D^\#}
  \]

  Equivalently:
  \[
    F_{D^\#}(a_1,..., a_i, ..., a_n) =  \alpha_{D^\#}(\{F(c_1,..., c_i, ..., c_n) | \forall i, 1 \le i \le n: c_i \in \gamma_{D^\#}(a_i)\})
  \]
\end{definition}

Intuitively, abstraction of operation is defined as the abstraction of a set, which contains results of all possible applications of function $F$ on concretizations of abstract arguments.

If the abstraction is not defined via Galois connection, the general approach is to over-approximate results of $F$. Therefore, we require $F_{D^\#}$ to be a sound abstraction \cite{CousotEtAl06-ASIAN}:

\[
  \forall a_i \in D^\#: F_{D^\#}((\gamma_{D^\#}(a_i))_{1 \le i \le n}) \subseteq \gamma_{D^\#}(F((a_i)_{1 \le i \le n}))
\]

Intuitively, no concrete case is omitted by abstract operation.

To demonstrate a particular abstract operation, we will define abstraction of integer addition using the integer interval domain:

\begin{definition}
  Let $F$ be integral addition, thus function of type $F: \mathbb Z \times \mathbb Z \to \mathbb Z$. The corresponding abstract operation $F_{D^\#}: D^\# \times D^\# \to D^\#$ in the integer interval domain is defined as \cite{mine-WING12}:
  \begin{align*}
    F_{D^\#}([l_1, h_1], [l_2, h_2]) &\triangleq \alpha_{D^\#}\left( v_1 + v_2 | v_1 \in \gamma_{D^\#}([l_1, h_1]), v_2 \in \gamma_{D^\#}([l_2, h_2]) \right)\\
    &\triangleq [l_1 + l_2, h_1 + h_2]
  \end{align*}
\end{definition}

Thanks to Galois connection, integer addition can be defined in the way indicated in definition \ref{def:operation-galois} -- we sum every pair of concrete values from the first and the second interval and then we apply abstraction function on the set of results.

It can be shown, that the procedure described is equivalent to an interval with lower and upper bounds corresponding to sum of lower bounds of the input intervals, respectively sum of upper bounds of the input intervals, as demonstrated by the following example:

\begin{exmp}
  \begin{align*}
    F_{D^\#}([1,1], [2,2]) &= [3,3]\\
    F_{D^\#}([1,3], [0,10]) &= [1,13]
  \end{align*}
\end{exmp}

The first example shows sum of two intervals, where each of them represents one concrete value. The latter example demonstrates a sum of two non-trivial intervals and it can be seen that the result interval is computed as sum of lower and upper bounds of the input intervals, respectively.

\chapter{Reduced product}\label{ch:reduced-product}

As demonstrated in example in the section \ref{sec:example}, a single abstract domain may not be able to accurately cover all possible abstract operations. To solve this issue, abstract interpretation provides two options:

\paragraph{One universal abstract domain}
Deploying one universal abstract domain requires no modification to abstract interpretation defined in previous chapters, but design of such universal abstract domain has shown as very difficult task, which may not be feasible or even possible.

\paragraph{Multiple specialized abstract domains}
The other choice is to modify abstract interpretation framework to allow parallel incorporating via multiple specialized abstract domain and provide refinement between domains to improve their accuracy. So each of these domains may capture a specific property of concrete value while ignoring other.

\vspace{1.5\baselineskip} % TODO

In this thesis we describe the second approach, because of its advantages. When designing a new abstract domain, this approach allows us to focus on the core functionality of the domain and does not burden us with necessity of implementing all possible abstract operations in accurate manner, which may not be possible or feasible.

However, the use of multiple specialized domains ultimately leads to the need for inter-domain accuracy refinements, which is the topic of this chapter. This chapter establishes \textit{domain product} in the section \ref{sec:domain-product}, which is later in the section \ref{sec:reduced-cardinality-product} extended into \textit{reduced cardinality product}.

\section{Domain product}\label{sec:domain-product}
% \begin{itemize}
%   \item Definition
%   \item Multiple representations of concrete value
% \end{itemize}

Motivation to introduce \textit{domain product} to abstract interpretation has been outlined in the beginning of this chapter - using a single abstract value to represent a program value would lead either to inaccurate results or complex implementation. Also it would not allow to deploy a new abstract domain tailored for a specific problem. \cite{CousotEtAl06-ASIAN}

To circumvent this obstacle, it is convenient to introduce a \textit{domain product}, which acts as encapsulation of abstract values representing the same program variable. From an external perspective, the domain products performs as a standalone abstract domain.

\textit{Domain product} is defined as follows \cite{CousotCousotMauborgne-FoSSaCS-11}:

\begin{definition}
  Let $\langle D^\#_i, \sqsubseteq_i \rangle$, $i \in I$, $I$ is finite, be abstract domains. Their Cartesian product is $\langle D^\#, \sqsubseteq \rangle$, where:
  \begin{align*}
    &D^\# \triangleq \bigtimes_{i \in I} D^\#_i\\
    &P \sqsubseteq Q \triangleq \bigwedge_{i \in I}\left(P_i \sqsubseteq_i Q_i \right)\\
    &\gamma_{D^\#}: \bigtimes_{i \in I} D^\#_i \to D\\
    &\gamma_{D^\#}(P) \triangleq \bigcap_{i \in I} \gamma_{D^\#_i}\left( P_i \right)
  \end{align*}
\end{definition}

Domain product $D^\#$ is defined as a simple Cartesian product of the contained abstract domains, thus contained values are independent of each other.

The semantics of $\sqsubseteq$ is naturally expanded to the set of contained domains as it is defined component-wise and $P \sqsubseteq Q$ is defined if and only if it is defined on all corresponding components of $P$ and $Q$.

The concretization function $\gamma_{D^\#}$ is intuitively defined as intersection of concretization of all contained abstract values.

To approach the definition, consider the following example of domain product of integer interval domain and an \textit{abstract domain representing parity}.

\begin{exmp}\label{exmp:domain-product}
  Definition of the integer interval domain and the parity domain:
  \begin{align*}
    &D = D_1 = D_2 = \mathcal P(\mathbb Z)\\
    &D^\#_1 = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &D^\#_2 = \{\bot, ev, od, \top\}\\
    &D^\# = D^\#_1 \times D^\#_2
  \end{align*}

  Example usage of the concretization function:
  \begin{align*}
    \gamma_{D^\#}(\left( [0, 4], \top \right)) &= \{0,1,2,3,4\}\\
    \gamma_{D^\#}(\left( [0, 4], od \right)) &= \{1,3\}
  \end{align*}
\end{exmp}

The example demonstrates domain product of two abstract domains and results of concretization function. As it may seem that concretization function $\gamma_{D^\#}$ provides the key to refinement of abstract values, we have to keep in mind that \textit{abstract functions are still applied component-wise}. Therefore we get the same results as in case of separate analyses, as stated in \cite{CousotCousot79-1}.

\section{Reduced product}\label{sec:reduced-cardinality-product}

As \textit{domain product} contains multiple abstract domains, each covering different aspect of concrete value, we may increase accuracy of contained domains by exploiting inter-domain refinements.

Intuitively, if one of the domains has inaccurately approximated a result of some concrete operation, while another domain was able to give an accurate abstraction, it would be convenient to enhance accuracy of the first domain using information provided by the second domain. Obviously the degree of improvement depends on the difference in the nature of abstraction used by domains.

\textit{Reduced product} provides framework for improvements of abstract domains contained in \textit{domain product}. But in order to preserve correctness of abstract interpretation, it has to hold the following:

\paragraph{Soundness}  A reduction of domain product has to keep its concrete semantics unmodified -- a concrete value it represents has to remain the same as before reduction.

\textit{Reduced product} is defined in the following way: \cite{CousotCousotMauborgne-FoSSaCS-11}

\begin{definition}
  Let $\langle D^\#, \sqsubseteq \rangle$ be a \textit{domain product} with concretization function $\gamma_{D^\#}$.

  Then \textit{reduced product} is $\langle D^\# /_\equiv, \sqsubseteq \rangle$, where equivalence is defined as  $\left(P \equiv Q \right) \triangleq \left(\gamma_{D^\#}(P) = \gamma_{D^\#}(Q) \right)$ and $\gamma_{D^\#}$ as well as $\sqsubseteq$ are naturally extended to the equivalence class $[P]/_\equiv$, $P \in D^\#$, of $\equiv$.
\end{definition}

The consequence of the soundness requirement is that reduced product can improve contained abstract values, but only to the point when it still stays in the same \textit{equivalence class of concrete values}, which is expressed by the definition.

Let us show usage of reduced product on the integer interval domain and the parity domain:

\begin{exmp}
  Let $D^\#_1$ be the integer interval domain and $D^\#_2$ be the parity domain (defined in example \ref{exmp:domain-product}).

  Reduction of abstract value $\left( [0,6], od \right)$:
  \begin{align*}
    D^\#_1 \times D^\#_2 &: \left( [0,6], od \right) \to \left([1, 5], od \right)\\
    \mathcal P(\mathbb Z) &: \{1,2,3,4,5\} \to \{1,2,3,4,5\}
  \end{align*}
\end{exmp}

The previous example demonstrates principles of reduced product -- while its concretization stays the same, the interval abstract value is refined to exclude boundaries, which are not odd. This can be achieved, because the parity abstract value was able to prove that the concrete value is always odd.

However, implementation of the most precise reduce product,as defined here, can hardly be modular and feasible \cite{CousotCousotMauborgne-FoSSaCS-11}, thus in practice only over-approximations are used. One approach to reduced product approximation is described in the following chapter.

\chapter{Implementation in \textsc{Canal}}\label{ch:implementation}
% \begin{itemize}
%   \item Overview of Canal
%   \item Overview of RP implementation
% \end{itemize}

This chapter addresses \textsc{Canal} project and its implementation of \textit{reduced product}.

\section{Introduction to \textsc{Canal} project}

\textsc{Canal} is a static analysis tool designed to analyze behaviour of
application programs written in C [language]. It is based on the theoretical
framework of abstract interpretation, with focus on the scalability to
large programs and proper handling of real-world source code. \cite{Canal}

It consists of three main components:

\begin{description}
  \item[Abstract domains] set of predefined abstract domains to cover machine integers, floating point numbers, arrays and structures
  \item[Interpreter] component responsible for source code traversal and program state management
  \item[Operations] translation from program instructions to operations on abstract values
\end{description}

Components \textit{abstract domains} and \textit{operations} correspond to entities described in chapter \ref{ch:abstract-interpretation}. \textit{Interpreter} involves concept of \textit{least fixed point} and it is interesting from technical point of view, because it incorporates LLVM libraries for interaction with source code.

LLVM is a a compiler framework, which provides a combination of key capabilities that are important for practical, lifelong analysis and
transformation of programs. \cite{llvm} It isolates \textsc{Canal} from machine-level semantics of C language and allows to offload processes associated with compiling and instruction-level analysis, therefore development of \textsc{Canal} can fully focus on abstract interpretation.

Provided the previous components, \textsc{Canal} is able to statically analyze general programs written in C. The high-level work flow can be described in the following way:

\begin{enumerate}
  \item Compilation of program source utilising LLVM compiler
  \item Load of resulting LLVM bytecode
  \item Initialization of program state using abstract values
  \item Translation of program instructions to abstract operations
  \item Execution of abstract operations on abstract values
\end{enumerate}

Abstract interpretation is involved from step 3 to step 5, particularly \textit{reduced product} is repeatedly deployed in step 5 to improve accuracy of abstract operation results.

\section{Framework of reduced product in \textsc{Canal}}

This section describes implementation of \textit{reduced product} based on theory introduced in chapter \ref{ch:reduced-product}. To remind, the target of reduced product is to improve accuracy of contained abstract values without changing its concrete semantics -- the result of concretization function. These accuracy improvements result in more accurate results of abstract operations, thus reducing the number of false positives and making the whole analysis more accurate.

Precisely this implementation is over-approximation of reduced product, because the most precise implementation of reduced product may be very hard if unfeasible. Also the most precise implementation would put constraints on modularity of the whole abstract interpretation framework, thus making its design and implementation difficult.

Therefore we have chosen to implement over-approximation of reduced product, which approaches the accuracy of the most precise reduced product via inter-domain communication, while keeping the property of soundness.

Principles of accuracy refinement are based on concept of inter-domain communication framework -- abstract values contained in reduced product are allowed to produce messages , which may be consumed by other domains and the contained information may lead to accuracy refinement.

Communication framework over-approximating reduced product consists of the following components:

\begin{description}
  \item[Domain product] encapsulates multiple abstract values
  \item[Communication protocol] enables inter-domain communication
  \item[Execution plan] defines process of inter-domain information exchange
\end{description}

When designing implementation, the functionality of communication framework was projected into existing OOP structure of \textsc{Canal} project and resulted into the following entities with the listed responsibilities:

\begin{description}
  \item[Container] provides encapsulation (\textit{domain product}) and defines execution order of message production and consumption (\textit{execution plan})
  \item[Messages] describe format of exchanged information (\textit{communication protocol})
  \item[Extract and Refine operations] define per-domain operations for message production and consumption and accuracy refinements (\textit{communication protocol})
\end{description}

At the beginning of analysis, for each program variable an instance of \textit{container} is initialized and filled with abstract values corresponding to the type of the variable. Since then, the container is treated by analysis as a single abstract value.

During the analysis of a given, all abstract operations applied on the container are passed component-wisely to the contained abstract values and after abstract operation application, the reduction phase is initiated.

Reduction phase is managed by container and depends on its internal structure. At first a particular abstract value is chosen from the container's content and asked to extract refinement information -- produce a message. Then this message is passed to the next abstract value, which refines itself using information from the message, produces a new message and the procedure is repeated until all contained abstract values had chance to refine themselves and influence accuracy of the other contained abstract values.

Implementation of the described process including the incorporated entities is described in the following sections.

\subsection{Container}

The container represents \textit{domain product} (defined in the section \ref{sec:domain-product}). To remind, domain products serves as an encapsulation for multiple abstract values representing the same program variable. And similarly is defined the first container's responsibility:

\paragraph{Encapsulation}
As the name suggests, the container has to encapsulate the contained abstract values, which means it stores the contained abstract values and from outside it acts as a single abstract value. If an abstract operation is issued, the container propagates the call to all contained abstract values component-wisely, thus emulating separate analyses of the program via different abstract domains.

\vspace{1\baselineskip} % TODO

Also the container has to fulfil a part of the \textit{reduced product} (defined in the section \ref{sec:reduced-cardinality-product}) over-approximation role -- therefore the following responsibility has to be implemented:

\paragraph{Inter-domain communication execution}
The container is required to initiate, manage and terminate the process of inter-domain communication. This involves invocation of message production \textit{in predefined order}, which is important, because the reduction approximation is not commutative operation, thus the result depends on order of execution.

Besides message production, it also controls message routing and message consumption invocation. The main aspect of message routing and consumption is the \textit{internal structure} of domain product, which determines the scope of message (recipients) and the order of reception -- the basic approach is to define a fixed order of contained abstract values and let all already produced messages to be consumed by all subsequent abstract values.

The whole process is terminated after a \textit{certain number of steps} depending on the number of contained abstract values. This number is chosen so as to allow message exchange between all contained abstract values.

\vspace{1\baselineskip} % TODO

The following diagrams shows the process of inter-domain communication:

\begin{figure}[ht!]
  \centering
  \begin {tikzpicture}
    [value/.style={rectangle,rounded corners,draw=black,thick,text width=6.5em,text centered},
    msg/.style={->,>=stealth,thick,shorten <=5pt,shorten >=5pt,auto}]

    \node[value] (interval) { Interval\\ $[0,5]$ };
    \node[value,right=of interval] (set) { Set\\ $\{0,3,5\}$ };
    \node[value,right=of set] (bitfield) { Bitfield\\ $\mathtt{0b000000TT1}$ };

    \path
      (interval) edge[msg,bend left=45]           node {$a$}               (set)
      (set)      edge[msg,bend left=45]           node {$a \cap b$}        (bitfield)
      (bitfield) edge[msg,->,bend left=45,dashed] node {$a \cap b \cap c$} (interval);
  \end {tikzpicture}
  \caption{Inter-domain communication}
  \label{fig:communication}
\end{figure}

The diagram \ref{fig:communication} demonstrates inter-domain communication inside of a container containing three abstract values. The communication is initiated by asking the \textit{interval} abstract value to produce a message $a$, which is routed to the \textit{set} abstract value. The \textit{set} consumes message $a$, while using the received information to improve its own accuracy.

Then it produces a new message $b$ and sends it combined with the message $a$ to the next abstract value. This procedure is repeated again, this time for the \textit{bitfield} abstract value.

The dashed edge connecting the last and the first abstract value expresses that the communication might be terminated at that point or the whole procedure might be repeated again taking all previously produced messages into the account.

\paragraph{Complexity} Intuitively the number of transmitted messages linearly depends on the number of contained abstract values $d$ and on the number of repetitions $r$:

\[
\mathcal O(d \cdot r)
\]

\paragraph{Partial correctness}
Partial correctness depends on the implementation of per-domain refinement and extract operation correctness.

But under this assumption, it can be intuitively seen that the algorithm sequentially propagates refinement information to all contained domain allowing them to refine itself, thus over-approximating \textit{reduced product}.

\paragraph{Termination}
As the number of contained domains is always finite and the number of repetitions is always fixed before executing the analysis, the proof of termination is trivial.

\paragraph{Implementation} The implementation of the previously described features is provided by \texttt{Product::Vector} class. Precisely contained abstract values are stored in a member variable \texttt{mValues}, which is an instance of  linked list \texttt{std::vector}. The order of linked list elements defines the order of message production and consumption.

Particularly the inter-domain communication is initiated in member function \texttt{collaborate}, which iterates through \texttt{mValues} list while invocating message production and consumption. This function also manages combining of previously transmitted messages with the current messages and controls the termination of communication.

All other member function serve as a proxy to propagate abstract functions calls to all contained abstract values.

\subsection{Messages}

The message entity mediates the information exchange between abstract values. While it mainly serves as an information carrier, it has also two responsibilities:

\paragraph{Modularity support}
In order to allow future expansion of reduced product to new abstract domains, the message has to provide interface, which permits simple addition of carried information without necessity to modify other parts of the abstract interpreter.

This issue addressed by splitting contained information into related chunks, which are managed separately, in out terminology we call these chunks \textit{message field}. An example of message field is given in the section \ref{sec:integer-reduced-product}

\paragraph{Combination of messages}
As the container spans the message scope to all subsequent message transmissions, it is necessary to provide support for merging the previous message with the current message.

Intuitively the semantics of merging two messages is to combine the contained refinement information in the way the result might provide better accuracy improvement than any of the two original messages separately. Thus the merge operation corresponds to the intersection of sets of concrete values represented by the message.

It is important to keep in mind this property when designing new \textit{message fields}

\paragraph{Implementation}
The implementation is partitioned between two classes: \texttt{Product::Message} and \texttt{Product::MessageField}.

\texttt{Product::Message} class defines a carrier for \textit{message fields} as member variable \texttt{mFields}, which is an instance of hashmap \texttt{std::map} -- the keys of this hashmaps represents type of message field, while the values are the particular message fields. Due to the usage of hashmap, only one instance of a particular message field type is allowed.

This class also defines member function \texttt{meet}, which takes another instance of this class as a parameter and performs combination of these two messages in the sense described above using member function \texttt{meet} of contained instances of \texttt{Product::MessageField}.

\texttt{Product::MessageField} class provides interface for implementing specific \textit{message fields}, which carry refinement information from one abstract value to another. The interface implementation of member function \texttt{meet}, which takes another instance of this class and performs combination of these two message fields. An example of message field can be found in the section \ref{sec:integer-reduced-product}.

\subsection{Extract and refine operations}

Extract and refine operations are inseparable part of reduced product implementation, because this is the place, where the actual accuracy refinements happen.

Both operations act as sockets exchanging information between two domains, where the extract operation represents the output socket while the refine operation stands for the input socket.

The basic idea is to synthesize useful information about the current abstract value and later use this information to improve accuracy of another domain. The most important thing to keep in mind when designing extract and refine operations is that the exchanged information has to \textit{preserve soundness of approximation}. Otherwise refinements using this information might break the correctness property of the analysis.

\paragraph{Extract operation}
Extract operation applied on a given abstract value results into message containing refinement information. The type of contained information may wary from one to another abstract domain as it highly depends on the property the domain is exploiting to provide abstraction.

An example is provided in the section \ref{sec:integer-reduced-product}.

\paragraph{Refine operation}
Refine operation attempts to improve accuracy of abstract value using refinement information from the received message. Again the degree of accuracy improvement highly depends on other domains contained in the container, respectively on types and content of received messages.

A significant refinement can occur, e.g. when the previously executed abstract operation was inaccurately over-approximated and the refinement operation was able to at least partially reconstruct the current abstract value.

However, an occurrence of no accuracy improvements is also possible, especially in the cases when the current abstract values was the only abstract value able to accurately approximate an abstract operation or the definition of the execution order prevented the current abstract value from receiving any messages.

An example can be found again in the section \ref{sec:integer-reduced-product}.

\paragraph{Implementation}
Interface for implementing \textit{extract} and \textit{refine} functions is defined in \texttt{Domain} class as member functions \texttt{extract} and \texttt{refine}. Both of them take an instance of \texttt{Product::Message} as the only argument and these function are expected to set respectively read refinement informations from the passed message.

\section{Integer reduced product}\label{sec:integer-reduced-product}

This section provides practical information about deploying \textit{reduced product} on existing abstract domains. Moreover, it might serve as a part of a guide covering topics on development of \textsc{Canal} project.

At the time of writing this thesis, \textsc{Canal} has 3 distinct abstract domains designed for analysing properties of integer variables:

\begin{description}
  \item[Interval] corresponding to the integer interval domain introduced in the chapter \ref{ch:abstract-interpretation}
  \item[Set] for precise representation of small sets of concrete values
  \item[Bitfield] covering binary-level semantics of integers
\end{description}

As it can be seen, these three abstract domains exploit almost orthogonal concepts of abstraction, thus making them ideal for usage in reduced product, because they provide mutually complementary functionality.

\subsection{\texttt{MinMax} message field design}

The first decision is to choose a suitable refinement information. The requirements for refinement information to be successful are the following:

\begin{description}
  \item[Easily extractable] obviously, if we are not able to extract the refinement information, we cannot produce a message, which is the primary condition for successful accuracy improvements
  \item[Easily refineable] having a very accurate refinement information without a possibility to apply them is also useless for accuracy improvements
  \item[Covering an inaccurate operation] providing refinement information, which are less accurate than the actual abstract value also leads to no accuracy improvements
\end{description}

Obviously, the minimal number of abstract domains which can be refined is 2 -- we need to have one abstract domain suitable for extraction of refinement information and another abstract domain, which is able to take the advantage of refinement information and improve its accuracy.

In our case we have chosen to implement \texttt{MinMax} message field, which basically is the integer interval domain. This choice allowed us to exchange information about lower and upper bounds between all three integer domains implemented in \textsc{Canal}.

\paragraph{Implementation}
Implementation can be found in class \texttt{Field::MinMax}, which is implementing the interface defined by \texttt{Product::MessageField}. The implementation incorporates an instance of the integer interval domain \texttt{Integer::Interval} which is stored in member variable \texttt{mInterval}.

The member function \texttt{meet} exploits the fact that this operation is already defined in \texttt{Integer::Interval} and uses this implementation -- intuitively \textit{meet} operation corresponds to the intersection of two intervals. This fact also transfers a burden of the correctness proof to the integer interval domain.

\subsection{Extract and refine implementation}

Implementation of these two methods on all three integer domains is fairly straightforward thanks to already implemented methods present on all related domains.

To remind, both two operations has to keep the property of soundness, otherwise the soundness of the whole analysis is lost.

\paragraph{Implementation}
Implementation of \texttt{extract} and \texttt{refine} member functions can be found in each of these three classes: \texttt{Integer::Interval}, \texttt{Integer::Set} and \texttt{Integer::Bitfield}. All of listed function are exploiting already defined member functions \texttt{signedMin}, \texttt{signedMax}, etc. for \textit{extract operation} and \texttt{fromInterval} for \textit{refine operation}.

\chapter{\textsc{GNU Core Utilities} analysis}\label{ch:measurements}

\chapter{Conclusion}

This thesis has briefly described the basic principles of \textit{abstract interpretation} and theory behind \textit{reduced product of abstract domain} while providing examples to help easier understanding of defined terms.

The second part of this paper discusses design, limitations and implementation of \textit{reduced product approximation} to \textsc{Canal} project. The usage of the defined framework is shown on integration with existing abstract domains and the corresponding provides helpful guide for the future application of reduced product to other abstract values.

The last chapter demonstrates the results of reduced product deployment on analysis of a set of real-life programs from \textsc{Gnu Coreutils} project.

The future work may include include optimized inter-domain communication framework, if the number of abstract domains \textsc{Canal} exceeds a certain volume. This would comprise improvements in the form of \textit{tree internal structure} or support for \textit{precondition refinements}. Also if encountered a specific pattern causing a loss of accuracy, new refinement messages may be designed and implemented to address this issue.

\bibliographystyle{plain}
\bibliography{reduced_product}

\end{document}