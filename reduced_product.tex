\documentclass[12pt,oneside]{fithesis2}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

% Better font rendering?
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

% Examples
\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]
\newtheorem{definition}{Definition}

% Additional symbols
\usepackage{mathabx}

% Pseudo-code
\usepackage[chapter]{algorithm}
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% URL formatting
\usepackage{url}

% Diagrams
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}

% Interactive references
\usepackage{hyperref}

% ToC setup
\usepackage[nottoc,numbib]{tocbibind}
\setcounter{tocdepth}{3}

\thesistitle{Reduced product of abstract domains}
\thesissubtitle{Bachelor thesis}
\thesisstudent{Jan Dupal}
\thesisfaculty{fi}
\thesisyear{spring 2013}
\thesisadvisor{Mgr. Karel Klíč}
\thesislang{en}

\begin{document}
\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
I would like to thank my supervisor...
\end{ThesisThanks}

\begin{ThesisAbstract}
Canal is a static analysis tool designed to analyse behaviour of application programs written in C. It is based on the theoretical framework of abstract interpretation, with focus on the scalability to large programs and proper handling of real-world source code.

Reduced product of abstract domains is a mechanism enabling an incremental evolution of abstract interpreter by introducing simple abstract domains one by one, and supporting program-specific domains. The reduced product itself is an abstract domain, and its operations (transformers) use the transformers of underlying domains component-wise. Underlying domains can improve their precision by exchanging information.

The goal of this thesis is to design and develop a generic reduced product in the context of Canal. The reduced product must provide means to exchange information between the underlying domains while keeping the domains themselves independent from each other. The impact of reduced product of integer intervals, bit field and set abstract domains on the analysis of numeric programs should be measured.
\end{ThesisAbstract}

\begin{ThesisKeyWords}
static analysis, abstract interpretation, reduced product, canal
\end{ThesisKeyWords}

\tableofcontents

\MainMatter
\chapter{Introduction}
\begin{itemize}
  \item program analysis (why?)
  \item static/dynamic
\end{itemize}

Program analysis is a field of Computer Science, which examines behaviour of programs.

\paragraph{Properties of programs}
The behaviour can be described by two distinct properties: \textit{correctness} and \textit{finiteness}.

Intuitively correctness expresses whether the program gives the same results as was intended. Formally...

Finiteness gives guarantee that program will finish it's computation in finite number of steps [citation needed].

\paragraph{Program analysis approaches}
In terms of approach program analysis is divided into two categories: dynamic and static analysis.

As the name suggests \textit{dynamic analysis} is performed on run-time. On the other hand \textit{static analysis} performed without actually executing the program. Obviously both approaches have advantages and disadvantages.

The dynamic analysis is capable of giving very precise results on given program input, where static analysis is input-independent, but it's results are more general, therefore less accurate \cite{CousotEtAl06-ASIAN}.

\section{Static program analysis}
\begin{itemize}
  \item utilization (runtime errors etc.)
  \item cons and pros
\end{itemize}

\section{Abstract interpretation}
\begin{itemize}
  \item basic principles
  \item concrete value - abstract value
\end{itemize}

When manually analysing behaviour of a given program by going through its source code, we often try to enumerate all possible values of a particular program variable. The knowledge of all possible values of the variable allow us to precisely reason about the results of expression incorporating that variable.

To correctly infer results of an expression, depending on cardinality of the expression, we take all possible combinations of input values and apply the expression. The result of our derivation is again a set of all possible values.

However, sometimes (e.g. in case of loops) the set of all possible values might be too large to memorize, so we have to resort to represent the set in another way. One option is to approximate the set as a certain property which is shared among all elements of the set. For example, a set of integers $\{1, 5, 9, 13, 17\}$ can be represented as \textit{odd integers}.

Approach to expressions evaluation is preserved -- first we \textit{concretize} the property representing the set of possible values, then we apply all possible combination of input values, resulting into a set of all possible results, which we \textit{abstract} to a property of the set.

Unconsciously we were using the concepts of \textit{abstract interpretation}.

\section{Reduced product}
\begin{itemize}
  \item References to chapters (theory)
\end{itemize}

\section{Project \textsc{Canal}}
\begin{itemize}
  \item Project goals
  \item References to chapters (implementation)
\end{itemize}


\chapter{Abstract interpretation}\label{ch:abstract-interpretation}
% \begin{itemize}
%   \item Term formalization
%   \item Theoretical frameworks
%   \item False alarms
%   \item Least fixed point
%   \item See Astre
% \end{itemize}

In some cases, a concrete question may not be answered easily. In those cases, we may resort to ask a simpler abstract question that results in an abstract answer.

Using this abstract answer we might be able to answer the original question or at least approximate the concrete answer. \cite{CousotCousot04-WCC}

\section{Usage in static analysis}

Analogous approach has shown as successful in static program analysis, where the concrete question is whether a given program is correct, i.e. the proof of the absence of run-time errors, which is proven to be undecidable \cite{mine-AIAA10}. This problem may be solved using abstraction to soundly approximate the answer. Therefore it is necessary to formalize those abstraction, which is the goal of \textit{abstract interpretation}.

The term abstract interpretation as described in \cite{CousotCousot77-1}:

\begin{quotation}
``A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using this denotation to describe computation in another universe of abstract objects, so that the results of abstract interpretation give some information on the actual computation.''
\end{quotation}

In other words, the goal of program analysis using abstract interpretation is to provide information about program computation. The tool it uses to reach the goal is \textit{abstraction of values and operations}.

\paragraph{Concrete value}
A concrete value stands for a program value. E.g. number 5 is a concrete value.

\paragraph{Abstract value}
An abstract value represents a set of concrete values of a given property (e.g. parity), depending on particular definition. This abstractions allows us to approximate results of concrete executions.

\paragraph{Abstract operations}
To be able to apply operation (e.g. sum of integers) on abstract values, it is necessary to define abstract operations. Abstract operations are used to transform input abstract values to output abstract values. And to be semantically correct, abstract operation must preserve the same behaviour as its concrete model regarding the property used to abstract values.

\vspace{1\baselineskip} % TODO

Given a program and the definitions of abstract values and operations, \textit{abstract interpretation} is able to interpret the program using abstract values instead of concrete values. The result of interpretation is information about properties of program values in each of program steps.


\subsection{Example}\label{sec:example}

To give a brief example of abstract values and operations consider the following computation from \cite{CousotCousot77-1}:

\[ -1515 \cdot 17 \]

To describe this concrete computation as an abstract computation, first we need to define values: symbols $(+)$ and $(-)$ to represent sign of concrete integral value and symbol $(\pm)$ for unknown sign.

Using this abstract values the previous computation corresponds to the following abstract computation:

\[ -(+) \cdot (+) \Rightarrow (-) \cdot (+) \Rightarrow (-) \]

Obviously the result of the first (concrete) computation expressed as abstract value is $(-)$, which is exactly the result of the second (abstract) computation.

\paragraph{Influence of operation}
However using addition instead of multiplication ($-1515 + 17$) leads to inaccurate result of abstract computation:

\[ -(+) + (+) \Rightarrow (-) + (+) \Rightarrow (\pm) \]

As you can see, the sign of the sum of negative and positive integer might be both $+$ or $-$, depending on which component is larger in absolute value. This unknown result is in our abstract universe expressed as $(\pm)$, generally denoted as $\top$.

\paragraph{Influence of abstraction}
Also the choice of abstract values affects accuracy of abstract computation. Choosing abstract values as $\{(even), (odd), \top\}$ to represent parity of integers instead of sign leads to the following results:

\[ -(odd) \cdot (odd) \Rightarrow (odd) \cdot (odd) \Rightarrow (odd) \]
\[ -(odd) + (odd) \Rightarrow (odd) + (odd) \Rightarrow (even) \]

The lack of $\top$ values in the results means that there was no accuracy lost when executing abstract computation.

\section{Theoretical framework}
% \begin{itemize}
%   \item What do abstract values represent?
%   \item Example - $+$, $-$, $\pm$, $|x|$, output
%   \item Abstract domains
%   \item False alarms
% \end{itemize}

This section describes formal requirements necessary to correctly design and implement an abstract interpretation framework including \textit{reduced product}.

\subsection{Domain of abstract values}

As abstract value represents a set of concrete values, so their domains preserve the same relation. \textit{Domain of abstract values} represents a set of all \textit{abstract values} and \textit{domain of concrete values} corresponds to a power set of all concrete values.

For easier comprehension, regard the following definition of \textit{integer interval domain}\cite{mine-WING12}, on which we will demonstrate the usage of defined terms in this chapter.

\textit{Integer interval domain} approximates a set of integers by a pair $[l, h]$, where $l$ and $h$ represents minimal and maximal element of the set, respectively. For example:

\[
  \{ 2, 1, 100, 4 \} \to [1, 100]
\]

As it can be seen, a set of integers $\{2, 1, 100, 4\}$ is represented by integer interval domain as a pair $[1, 100]$. This so called \textit{abstraction function} is later formalized in \ref{ssec:abstraction-function}.

Formal definition of domains used in the \textit{integer interval domain} follows:

\begin{exmp}
  \begin{align*}
    &D = \mathcal P(\mathbb Z)\\
    &D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
  \end{align*}
\end{exmp}

The \textit{domain of concrete values} $D$, in case of integers, is a power set of integers $\mathbb Z$. To remind, a concrete value denotes any program value and their set describes all possible values of a given program value.

And the \textit{domain of abstract values} $D^\#$ is defined to approximate sets of concrete values from $D$. In this case, it is a set of all pairs $[l, h]$, where $l$ and $h$ are integers or symbols representing positive or negative infinity.

This abstraction was chosen, because it belongs to the basic abstractions used in analysis of numerical computation\cite{mine-AIAA10} and its underlying concepts are easy to understand.

By convention, a domain of concrete values will further be denoted as $D$ and a domain of abstract values as $D^\#$ and their elements as $a$ and $C$ respectively.

\subsection{Abstraction function}\label{ssec:abstraction-function}

The correspondence between sets of concrete values and abstract values is established by the \textit{abstraction function} \cite{CousotCousot76-1}:

\[
\alpha_{D^\#}\colon D \to D^\#
\]

The \textit{abstraction function} assigns an abstract value to a given set of concrete values. It belongs to the core concepts of the abstract interpretation, because it provides bridge between a program values and their abstraction -- every program value has to be abstracted before proceeding with abstract interpretation of the program.

To give a particular \textit{abstraction function}, consider the one used in integer interval domain:

\begin{exmp}
  \begin{align*}
    % D = \mathcal P(\mathbb Z)\\
    % D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &\alpha_{D^\#}(C) \triangleq [min(C), max(C)]\\
    &\alpha_{D^\#}(\{-1, 0, 3\}) = [-1, 3]\\
    &\alpha_{D^\#}(\mathbb Z) = [-\infty, \infty]
  \end{align*}
\end{exmp}

As it was outlined in the introduction to this section, the \textit{integer interval domain} represents sets of concrete values as a pair of minimal and maximal element -- the bounds of the interval.

The example demonstrates application of \textit{abstraction function} $\alpha_{D^\#}$ on a small set of integers, which is rather obvious. And the second application shows interval $[-\infty, \infty]$ corresponding to the set of all integers, $\mathbb Z$.

Note that this particular abstraction may include in the approximation some excessive concrete values due to its definition utilizing only minimal and maximal element -- this property of abstraction is denoted as \textit{incompleteness} and will be defined later in \ref{ssec:soundness-incompleteness}.

\subsection{Concretization function}
Dually to abstraction function, \textit{concretization function} transforms an abstract value into a set of concrete values, which are represented by the given abstract value.

Importance of this function lies in the fact, that it defines a concrete semantics of abstract values -- it enables us to translate results of abstract interpretation into the universe of abstract values. And last but not least, together with abstract functions, it defines almost all subsequent terms of abstract interpretation.

A \textit{concretization function} is a function of type:

\[
\gamma_{D^\#}\colon D^\# \to D
\]

One example is the concretization function of the \textit{integer interval domain}:

\begin{exmp}
  \begin{align*}
    % D = \mathcal P(\mathbb Z)\\
    % D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &\gamma_{D^\#}([l,h]) \triangleq \{x \in \mathbb Z | l \le x \le h\}\\
    &\gamma_{D^\#}([-1,3]) = \{-1, 0, 1, 2, 3\}\\
    &\gamma_{D^\#}([-\infty, \infty]) = \mathbb Z
  \end{align*}
\end{exmp}

Concretization function of the integer interval domain converts an interval into a set of all integers lying between the bounds of the interval, including the bounds.

As you can see, this concretization function does not omit any of the concrete values inside the interval, thanks of the definition, which over-approximates the set of concrete values, thus giving guarantee on \textit{soundness} -- this property is formalized in \ref{ssec:soundness-incompleteness}.

\subsection{Partial order of abstract and concrete values}

Since the domain of concrete values is defined as a power set, it can be partially ordered by set inclusion $\subseteq$. This property is interesting to abstract interpretation, because it allows to compare sets of abstract values in the sense of ``is included in'', which is a useful feature e.g. when computing a fixed point of a given loop in a program.

Dually we define partial order on the domain of abstract values via $\sqsubseteq$ also expressing ``is included in''. Again, this relation enables us to compare abstract values and e.g. compute abstract fix point of a loop or of a complete program.

Generally the $\sqsubseteq$ is defined as follows:

\begin{definition}
  Let $A_1, A_2 \in D^\#$, then
  \[
    A_1 \sqsubseteq A_2 \triangleq \gamma_{D^\#}(A_1) \subseteq \gamma_{D^\#}(A_2)
  \]
\end{definition}


The following demonstration shows definition of $\sqsubseteq$ and a link between $\subseteq$ and $\sqsubseteq$ in the integer interval domain:

\begin{exmp}
  \begin{align*}
    [l_1, h_1] \sqsubseteq [l_2, h_2] &\triangleq l_1 \ge l_2 \wedge h_1 \le h_2\\
    \emptyset \subseteq \{1\} &\subseteq \{0, 1, 2\} \subseteq \mathbb Z\\
    [1,0] \sqsubseteq [1,1] &\sqsubseteq [0,2] \sqsubseteq [-\infty,\infty]
  \end{align*}
\end{exmp}

As it can be seen, if the sets of concrete values do not omit any value between minimal and maximal element, operators $\subseteq$ and $\sqsubseteq$ correspond precisely. However, if the set of concrete values does not cover the whole range, $\not\subseteq$ may not imply $\not\sqsubseteq$ -- observe the following example:

\begin{exmp}
  \begin{align*}
    \{0, 7\} \not\subseteq \{4, 5\} &\Rightarrow [0,7] \not\sqsubseteq [4,5]\\
    \{ 4, 5\} \not\subseteq \{0, 7\} &\not\Rightarrow [4,5] \not\sqsubseteq [0,7]\\
  \end{align*}
\end{exmp}

While the first case in the last example confirms the implication, the second serves as a counterexample. This example demonstrates the consequences of using approximations in static analysis, a deeper insight into properties of approximation is provided by section \ref{ssec:soundness-incompleteness}.

Using partial order defined by $\sqsubseteq$ and defining $\bot$ and $\top$ as minimal and maximal elements of the set $D^\#$, we are able to construct a lattice of abstract values.

\begin{figure}[ht!]
  \centering
  \begin {tikzpicture}[on grid]
    % nodes
    \node (bot) at (0,-1) { $\bot$ };

    \node (-3_-3) at (-6,1) {};
    \node (-2_-2) at (-4,1) { $[-2, -2]$ };
    \node (-1_-1) at (-2,1) { $[-1, -1]$ };
    \node (0_0) at (0,1) { $[0, 0]$ };
    \node (1_1) at (2,1) { $[1, 1]$ };
    \node (2_2) at (4,1) { $[2, 2]$ };
    \node (3_3) at (6,1) {};

    \node (-3_-2) at (-5,2) {};
    \node (-2_-1) at (-3,2) { $[-2, -1]$ };
    \node (-1_0) at (-1,2) { $[-1, 0]$ };
    \node (0_1) at (1,2) { $[0, 1]$ };
    \node (1_2) at (3,2) { $[1, 2]$ };
    \node (2_3) at (5,2) {};

    \node (-3_-1) at (-4,3) {};
    \node (-2_0) at (-2,3) { $[-2, 0]$ };
    \node (-1_1) at (0,3) { $[-1, 1]$ };
    \node (0_2) at (2,3) { $[0, 2]$ };
    \node (1_3) at (4,3) {};

    \node (-3_0) at (-3,4) {};
    \node (-2_1) at (-1,4) { $[-2, 1]$ };
    \node (-1_2) at (1,4) { $[-1, 2]$ };
    \node (0_3) at (3,4) {};

    \node (-3_1) at (-2,5) {};
    \node (-2_2) at (0,5) { $[-2, 2]$ };
    \node (-1_3) at (2,5) {};

    \node (-3_2) at (-1,6) {};
    \node (-2_3) at (1,6) {};

    \node (top) at (0,8) { $\top$ };
    \node (subt0) at (-4, 6.5) {};
    \node (subt1) at (-2, 6.5) {};
    \node (subt2) at (0, 6.5) {};
    \node (subt3) at (2, 6.5) {};
    \node (subt4) at (4, 6.5) {};

    % lines
    \draw[dashed] ($(bot) !.5! (-3_-3) $) -- ($(bot) !.9! (-3_-3) $);
    \draw         (bot) -- ($(bot) !.5! (-3_-3) $);
    \draw         (bot) -- (-2_-2);
    \draw         (bot) -- (-1_-1);
    \draw         (bot) -- (0_0);
    \draw         (bot) -- (1_1);
    \draw         (bot) -- (2_2);
    \draw         (bot) -- ($(bot) !.5! (3_3) $);
    \draw[dashed] ($(bot) !.5! (3_3) $) -- ($(bot) !.9! (3_3) $);

    \draw[dashed] (-2_-2) -- ($(-2_-2) !.8! (-3_-2) $);
    \draw         (-2_-2) -- (-2_-1);
    \draw         (-1_-1) -- (-2_-1);
    \draw         (-1_-1) -- (-1_0);
    \draw         (0_0)   -- (-1_0);
    \draw         (0_0)   -- (0_1);
    \draw         (1_1)   -- (0_1);
    \draw         (1_1)   -- (1_2);
    \draw         (2_2)   -- (1_2);
    \draw[dashed] (2_2)   -- ($(2_2) !.8! (2_3) $);

    \draw[dashed] (-2_-1) -- ($(-2_-1) !.8! (-3_-1) $);
    \draw         (-2_-1) -- (-2_0);
    \draw         (-1_0)  -- (-2_0);
    \draw         (-1_0)  -- (-1_1);
    \draw         (0_1)   -- (-1_1);
    \draw         (0_1)   -- (0_2);
    \draw         (1_2)   -- (0_2);
    \draw[dashed] (1_2)   -- ($(1_2) !.8! (1_3) $);

    \draw[dashed] (-2_0) -- ($(-2_0) !.8! (-3_0) $);
    \draw         (-2_0) -- (-2_1);
    \draw         (-1_1) -- (-2_1);
    \draw         (-1_1) -- (-1_2);
    \draw         (0_2)  -- (-1_2);
    \draw[dashed] (0_2) -- ($(0_2) !.8! (0_3) $);

    \draw[dashed] (-2_1) -- ($(-2_1) !.8! (-3_1) $);
    \draw         (-2_1) -- (-2_2);
    \draw         (-1_2) -- (-2_2);
    \draw[dashed] (-1_2) -- ($(-1_2) !.8! (-1_3) $);

    \draw[dashed] (-2_2) -- ($(-2_2) !.8! (-3_2) $);
    \draw[dashed] (-2_2) -- ($(-2_2) !.8! (-2_3) $);

    \draw[dashed] (top) -- ($(top) !.66! (subt0) $);
    \draw[dashed] ($(top) !.5! (subt1) $) -- (subt1);
    \draw         (top) -- ($(top) !.5! (subt1) $);
    \draw[dashed] ($(top) !.5! (subt2) $) -- (subt2);
    \draw         (top) -- ($(top) !.5! (subt2) $);
    \draw[dashed] ($(top) !.5! (subt3) $) -- (subt3);
    \draw         (top) -- ($(top) !.5! (subt3) $);
    \draw[dashed] (top) -- ($(top) !.66! (subt4) $);
  \end {tikzpicture}
  \caption{Lattice of integer interval domain}
  \label{fig:interval-lattice}
\end{figure}

The figure \ref{fig:interval-lattice} show a part of infinite lattice of the integer interval abstract domain. The edges correspond to $\sqsubseteq$ relation except for transitivity. As it can be seen, the lowest level represents an abstract value corresponding to an empty set. One level higher are placed intervals standing for sets of length one and edges connect them to intervals in upper level while expressing ``is included in'' relation.

% \begin{figure}[ht!]
%   \centering
%   \begin {tikzpicture}[node distance=1.5cm]
%     \node (Top) { $\top$ };
%     \node (Even) [below left=of Top] { $ev$ };
%     \node (Odd) [below right=of Top] { $od$ };
%     \node (Bottom) [below right=of Even] { $\bot$ };
%     \draw (Top) -- (Even);
%     \draw (Top) -- (Odd);
%     \draw (Even) -- (Bottom);
%     \draw (Odd) -- (Bottom);
%   \end {tikzpicture}
%   \caption{Lattice of parity domain}
% \end{figure}

\subsection{Correctness of approximation}\label{ssec:soundness-incompleteness}

If we want to gain informative results via a program analysis, we have to ensure that the analysis is \textit{correct}. Correctness consists of three distinct properties: \textit{soundness}, \textit{completeness} and \textit{termination}.

\paragraph{Soundness}
Soundness expresses, that a given abstraction do include every case having a particular property, but since it is an over-approximations, some of those cases might not occur in the reality.

In order to be sound analysis, the abstraction and concretization functions has to satisfy the following requirement \cite{mine-AIAA10}:

\[
  \forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

Intuitively soundness means, that no concrete value is omitted by abstraction. In the context of program analysis, soundness represents the \textit{lack of false negatives}, which is often required property.

For example, when analysing a program and there is a \textit{possibility} of zero division occurrence, sound analysis has to report this fact.

The proof of soundness of integer interval domain is as follows:

\begin{proof}
  Let $D$, $D^\#$, $\alpha_{D^\#}$ and $\gamma_{D^\#}$ be defined as in the integer interval domain. We want to prove:
  \[
    \forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
  \]
  Via definition:
  \begin{align*}
    \gamma_{D^\#}(\alpha_{D^\#}(C)) &= \gamma_{D^\#}([min(C), max(C)])\\
    &= \{ x \in \mathbb Z | min(C) \le x \le max(C) \}
  \end{align*}
  When substituted into the original expression:
  \[
    \forall C \in \mathcal P(\mathbb Z): C \subseteq \{ x \in \mathbb Z | min(C) \le x \le max(C) \}
  \]
  Which proves soundness of the integer interval domain.
\end{proof}

\paragraph{Completeness}
Dually to soundness, completeness represent guarantee that any statement proved in abstract is also valid in concrete \cite{mine-AIAA10}, which means that a statement derived from abstraction is truthful for every individual concrete case.

Completeness requires the following \cite{mine-AIAA10}:

\[
  \forall C \in D: C \supseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

In the context of abstract analysis, completeness corresponds to the \textit{absence of false positives}. For example, false positive result is case when program analysis reports zero division, while it is not possible to occur.

Since abstract interpretation does not require completeness (reason will be given later), it might not be present as we can prove in case of the integer interval domain:

\begin{proof}
  Let $D$, $D^\#$, $\alpha_{D^\#}$ and $\gamma_{D^\#}$ be defined as in the integer interval domain. We want to refute:
  \[
    \forall C \in D: C \supseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
  \]
  We will use counterexample $C = \{1, 3\}$:
  \begin{align*}
    \gamma_{D^\#}(\alpha_{D^\#}(\{1, 3\})) &= \gamma_{D^\#}([1, 3])\\
    &= \{1, 2, 3\}
  \end{align*}
  Obviously:
  \[
    \{1, 3\} \not\supseteq \{1, 2, 3\}
  \]
  Which proves \textit{incompleteness} of the integer interval domain.
\end{proof}

\paragraph{Termination} Termination is also very important property of a program analysis. However, termination is mainly matter of fix point computation, which is not the topic of this thesis. Details can be found in \cite{CousotCousot79-1}.

To conclude this section, abstract interpretation requires \textit{soundness} and \textit{termination}, while \textit{completeness} is not achievable as in case of all sound formal methods \cite{CousotEtAl06-ASIAN}.

\subsection{Galois connection}

When designing an abstract interpretation framework, one of methods shown in \cite{CousotCousot92-2} is via defining \textit{Galois connection} as introduced in \cite{CousotCousot76-1}. Galois connection puts constraints on abstraction and concretization function in exchange of interesting properties, e.g. ``best'' approximation, which will be described later in this section.

Galois connection is defined via a pair of adjoined functions $\langle \alpha_{D^\#}, \gamma_{D^\#} \rangle$ as followed: \cite{CousotCousot79-1}

\begin{definition}
  Let $\langle D, \subseteq \rangle$, $\langle D^\#, \sqsubseteq \rangle$ be posets and $\alpha_{D^\#}$, $\gamma_{D^\#}$ abstraction and concretization functions respectively.

  A pair $\langle \alpha_{D^\#}, \gamma_{D^\#} \rangle$ defines Galois connection if the following criteria are met.
  \begin{enumerate}
    \item $\alpha_{D^\#}$ and $\alpha_{D^\#}$ are \textit{isotone}, in terms of $\subseteq$ and $\sqsubseteq$
    \item $\forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))$
    \item $\forall a \in D^\#: a \subseteq \alpha_{D^\#}(\gamma_{D^\#}(a))$
  \end{enumerate}
\end{definition}

Intuitively, the presence of \textit{Galois connection} ensures that any concrete value $T \in D$ has a ``best'' approximation $\alpha_{D^\#}(T)$, that over-approximates $T$ as $T \subseteq \gamma_{D^\#}(\alpha_{D^\#}(T))$. And given any other over-approximation $R \in D^\#$, so $T \subseteq \gamma_{D^\#}(R)$, then $\alpha_{D^\#}(T)$ is more precise, because $\alpha_{D^\#}(T) \sqsubseteq R$.

% TODO draw a diagram representing GC

Galois connection also allows us to define \textit{soundness} and \textit{completeness} dually (via abstract values instead of concrete values). Moreover, it also defines \textit{abstract operation} in a precise way as shown in \ref{sec:operations}.

\subsection{Abstract operations}\label{sec:operations}

As stated in the introduction, abstract operation (sometimes referred as \textit{abstract transformers}) enable to approximate results of transformations defined in programs.

In case of Galois connection, abstract operations are precisely defined, because we can exploit properties of abstraction and concretization functions.

\begin{definition}\label{def:operation-galois}
  For any concrete $n$-ary primitive $F: C^n \to C$, where $C \in D$, abstract operation $F_{D^\#}$ is defined: \cite{mine-AIAA10}

  \[
    F_{D^\#} \triangleq \alpha_{D^\#} \circ F \circ \gamma_{D^\#}
  \]

  Equivalently:
  \[
    F_{D^\#}(a_1,..., a_i, ..., a_n) =  \alpha_{D^\#}(\{F(c_1,..., c_i, ..., c_n) | \forall i, 1 \le i \le n: c_i \in \gamma_{D^\#}(a_i)\})
  \]
\end{definition}

Intuitively, abstraction of operation is defined as the abstraction of a set, which contains results of all possible applications of function $F$ on concretizations of abstract arguments.

If the abstraction is not defined via Galois connection, the general approach is to over-approximate results of $F$. Therefore, we require $F_{D^\#}$ to be a sound abstraction \cite{CousotEtAl06-ASIAN}:

\[
  \forall a_i \in D^\#: F_{D^\#}((\gamma_{D^\#}(a_i))_{1 \le i \le n}) \subseteq \gamma_{D^\#}(F((a_i)_{1 \le i \le n}))
\]

Intuitively, no concrete case is omitted by abstract operation.

To demonstrate a particular abstract operation, we will define abstraction of integer addition using the integer interval domain:

\begin{definition}
  Let $F$ be integral addition, thus function of type $F: \mathbb Z \times \mathbb Z \to \mathbb Z$. The corresponding abstract operation $F_{D^\#}: D^\# \times D^\# \to D^\#$ in the integer interval domain is defined as \cite{mine-WING12}:
  \begin{align*}
    F_{D^\#}([l_1, h_1], [l_2, h_2]) &\triangleq \alpha_{D^\#}\left( v_1 + v_2 | v_1 \in \gamma_{D^\#}([l_1, h_1]), v_2 \in \gamma_{D^\#}([l_2, h_2]) \right)\\
    &\triangleq [l_1 + l_2, h_1 + h_2]
  \end{align*}
\end{definition}

Thanks to Galois connection, integer addition can be defined in the way indicated in definition \ref{def:operation-galois} -- we sum every pair of concrete values from the first and the second interval and then we apply abstraction function on the set of results.

It can be shown, that the procedure described is equivalent to an interval with lower and upper bounds corresponding to sum of lower bounds of the input intervals, respectively sum of upper bounds of the input intervals, as demonstrated by the following example:

\begin{exmp}
  \begin{align*}
    F_{D^\#}([1,1], [2,2]) &= [3,3]\\
    F_{D^\#}([1,3], [0,10]) &= [1,13]
  \end{align*}
\end{exmp}

The first example shows sum of two intervals representing only one concrete values, which result is obvious. The latter example demonstrates a sum of two non-trivial intervals and it can be seen that the result interval is computed as sum of lower and upper bounds of the input intervals, respectively.

\chapter{Reduced product}\label{ch:reduced-product}

As demonstrated in example in section \ref{sec:example}, a single abstract domain may not be able to accurately cover all possible abstract operations. To solve this issue, abstract interpretation provides two options:

\paragraph{One universal abstract domain}
Deploying one universal abstract domain requires no modification to abstract interpretation defined in previous chapters, but design of such universal abstract domain has shown as very difficult task, which may not be feasible or even possible.

\paragraph{Multiple specialized abstract domains}
The other choice is to modify abstract interpretation framework to allow parallel incorporating via multiple specialized abstract domain and provide refinement between domains to improve their accuracy. So each of these domains may capture a specific property of concrete value while ignoring other.

\vspace{1.5\baselineskip} % TODO

In this thesis we describe the second approach, because of its advantages:

When designing a new abstract domain, this approach allows us to focus on the core functionality of the domain and does not burden us with necessity of implementing all possible abstract operations in accurate manner, which may not be possible or feasible.

But it ultimately leads to the need for inter-domain accuracy refinements, which is the topic of this chapter. This chapter establishes \textit{domain product} in section \ref{sec:domain-product}, which is later in section \ref{sec:reduced-cardinality-product} extended into \textit{reduced cardinality product}.

\section{Domain product}\label{sec:domain-product}
% \begin{itemize}
%   \item Definition
%   \item Multiple representations of concrete value
% \end{itemize}

Motivation to introduce \textit{domain product} to abstract interpretation has been outlined in the beginning of this chapter - using a single abstract value to represent a program value would lead either to inaccurate results or complex implementation. Also it would not allow to deploy a new abstract domain tailored for a specific problem. \cite{CousotEtAl06-ASIAN}

To circumvent this obstacle, it is convenient to introduce a \textit{domain product}, which acts as encapsulation of abstract values representing the same program variable. From an external perspective, the domain products performs as a standalone abstract domain.

\textit{Domain product} is defined as follows \cite{CousotCousotMauborgne-FoSSaCS-11}:

\begin{definition}
  Let $\langle D^\#_i, \sqsubseteq_i \rangle$, $i \in I$, $I$ is finite, be abstract domains. Their Cartesian product is $\langle D^\#, \sqsubseteq \rangle$, where:
  \begin{align*}
    &D^\# \triangleq \bigtimes_{i \in I} D^\#_i\\
    &P \sqsubseteq Q \triangleq \bigwedge_{i \in I}\left(P_i \sqsubseteq_i Q_i \right)\\
    &\gamma_{D^\#}: \bigtimes_{i \in I} D^\#_i \to D\\
    &\gamma_{D^\#}(P) \triangleq \bigcap_{i \in I} \gamma_{D^\#_i}\left( P_i \right)
  \end{align*}
\end{definition}

Domain product $D^\#$ is defined as a simple Cartesian product of the contained abstract domains, thus contained values are independent of each other.

The semantics of $\sqsubseteq$ is naturally expanded to the set of contained domains as it is defined component-wise and $P \sqsubseteq Q$ is defined if and only if it is defined on all corresponding components of $P$ and $Q$.

The concretization function $\gamma_{D^\#}$ is intuitively defined as intersection of concretization of all contained abstract values.

To approach the definition, consider the following example of domain product of integer interval domain and an \textit{abstract domain representing parity}.

\begin{exmp}\label{exmp:domain-product}
  Definition of the integer interval domain and the parity domain:
  \begin{align*}
    &D = D_1 = D_2 = \mathcal P(\mathbb Z)\\
    &D^\#_1 = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &D^\#_2 = \{\bot, ev, od, \top\}\\
    &D^\# = D^\#_1 \times D^\#_2
  \end{align*}

  Example usage of the concretization function:
  \begin{align*}
    \gamma_{D^\#}(\left( [0, 4], \top \right)) &= \{0,1,2,3,4\}\\
    \gamma_{D^\#}(\left( [0, 4], od \right)) &= \{1,3\}
  \end{align*}
\end{exmp}

The example demonstrates domain product of two abstract domains and results of concretization function. As it may seem that concretization function $\gamma_{D^\#}$ provides the key to refinement of abstract values, we have to keep in mind that \textit{abstract functions are still applied component-wise}. Therefore we get the same results as in case of separate analyses, as stated in \cite{CousotCousot79-1}.

\section{Reduced product}\label{sec:reduced-cardinality-product}

As \textit{domain product} contains multiple abstract domains, each covering different aspect of concrete value, we may increase accuracy of contained domains by exploiting inter-domain refinements.

Intuitively, if one of the domains has inaccurately approximated a result of some concrete operation, while another domain was able to give an accurate abstraction, it would be convenient to enhance accuracy of the first domain using information provided by the second domain. Obviously the degree of improvement depends on the difference in the nature of abstraction used by domains.

\textit{Reduced product} provides framework for improvements of abstract domains contained in \textit{domain product}. But in order to preserve correctness of abstract interpretation, it has to hold the following:

\paragraph{Soundness}  A reduction of domain product has to keep its concrete semantics unmodified -- a concrete value it represents has to remain the same as before reduction.

\textit{Reduced product} is defined in the following way: \cite{CousotCousotMauborgne-FoSSaCS-11}

\begin{definition}
  Let $\langle D^\#, \sqsubseteq \rangle$ be a \textit{domain product} with concretization function $\gamma_{D^\#}$.

  Then \textit{reduced product} is $\langle D^\# /_\equiv, \sqsubseteq \rangle$, where equivalence is defined as  $\left(P \equiv Q \right) \triangleq \left(\gamma_{D^\#}(P) = \gamma_{D^\#}(Q) \right)$ and $\gamma_{D^\#}$ as well as $\sqsubseteq$ are naturally extended to the equivalence class $[P]/_\equiv$, $P \in D^\#$, of $\equiv$.
\end{definition}

The consequence of the soundness requirement is that reduced product can improve contained abstract values, but only to the point when it still stays in the same \textit{equivalence class of concrete values}, which is expressed by the definition.

Let us show usage of reduced product on the integer interval domain and the parity domain:

\begin{exmp}
  Let $D^\#_1$ be the integer interval domain and $D^\#_2$ be the parity domain (defined in example \ref{exmp:domain-product}).

  Reduction of abstract value $\left( [0,6], od \right)$:
  \begin{align*}
    D^\#_1 \times D^\#_2 &: \left( [0,6], od \right) \to \left([1, 5], od \right)\\
    \mathcal P(\mathbb Z) &: \{1,2,3,4,5\} \to \{1,2,3,4,5\}
  \end{align*}
\end{exmp}

The previous example demonstrates principles of reduced product -- while its concretization stays the same, the interval abstract value is refined to exclude boundaries, which are not odd. This can be achieved, because the parity abstract value was able to prove that the concrete value is always odd.

However, implementation of the most precise reduce product,as defined here, can hardly be modular and feasible \cite{CousotCousotMauborgne-FoSSaCS-11}, thus in practice only over-approximations are used. One approach to reduced product approximation is described in the following chapter.

\chapter{Implementation in \textsc{Canal}}
% \begin{itemize}
%   \item Overview of Canal
%   \item Overview of RP implementation
% \end{itemize}

This chapter addresses \textsc{Canal} project and its implementation of \textit{reduced product}.

\section{Introduction to \textsc{Canal} project}

\textsc{Canal} is a static analysis tool designed to analyze behaviour of
application programs written in C [language]. It is based on the theoretical
framework of abstract interpretation, with focus on the scalability to
large programs and proper handling of real-world source code. \cite{Canal}

It consists of three main components:

\begin{description}
  \item[Abstract domains] set of predefined abstract domains to cover machine integers, floating point numbers, arrays and structures
  \item[Interpreter] component responsible for source code traversal and program state management
  \item[Operations] translation from program instructions to operations on abstract values
\end{description}

Components \textit{abstract domains} and \textit{operations} correspond to entities described in chapter \ref{ch:abstract-interpretation}. \textit{Interpreter} involves concept of \textit{least fixed point} and it is interesting from technical point of view, because it incorporates LLVM libraries for interaction with source code.

LLVM is a a compiler framework, which provides a combination of key capabilities that are important for practical, lifelong analysis and
transformation of programs. \cite{llvm} It isolates \textsc{Canal} from machine-level semantics of C language and allows to offload processes associated with compiling and instruction-level analysis, therefore development of \textsc{Canal} can fully focus on abstract interpretation.

Provided the previous components, \textsc{Canal} is able to statically analyze general programs written in C. The high-level work flow can be described in the following way:

\begin{enumerate}
  \item Compilation of program source utilising LLVM compiler
  \item Load of resulting LLVM bytecode
  \item Initialization of program state using abstract values
  \item Translation of program instructions to abstract operations
  \item Execution of abstract operations on abstract values
\end{enumerate}

Abstract interpretation is involved from step 3 to step 5, particularly \textit{reduced product} is repeatedly deployed in step 5 to improve accuracy of abstract operation results.

\section{Framework of reduced product in \textsc{Canal}}

This section describes implementation of \textit{reduced product} based on theory introduced in chapter \ref{ch:reduced-product}. To remind, the target of reduced product is to improve accuracy of contained abstract values without changing its concrete semantics -- the result of concretization function.

Precisely this implementation is over-approximation of reduced product, because the most precise implementation of reduced product may be very hard if unfeasible. Also the most precise implementation would put constraints on modularity of the whole abstract interpretation framework, thus making its design and implementation difficult.

Therefore we have chosen to implement over-approximation of reduced product, which approaches the accuracy of the most precise reduced product via inter-domain communication, while keeping the property of soundness.

Principles of accuracy refinement are based on concept of inter-domain communication framework -- abstract values contained in reduced product are allowed to produce messages , which may be consumed by other domains and the contained information may lead to accuracy refinement.

Communication framework over-approximating reduced product consists of the following components:

\begin{description}
  \item[Domain product] encapsulates multiple abstract values
  \item[Communication protocol] enables inter-domain communication
  \item[Execution plan] defines process of inter-domain information exchange
\end{description}

When designing implementation, the functionality of communication framework was projected into existing OOP structure of \textsc{Canal} project and resulted into the following entities with specified responsibilities:

\begin{description}
  \item[Container] provides encapsulation (domain product) and defines order of execution of message production and consumption (execution plan)
  \item[Messages] describe format of exchanged information
  \item[Execution plan] defines process of inter-domain information exchange
\end{description}

\subsection{Container}
\begin{itemize}
  \item Vector, Tree
  \item Cons and pros
\end{itemize}

\subsection{Messages}
\begin{itemize}
  \item Kind of messages
  \item Meet
\end{itemize}

\subsection{Extract and Refine operations}
\begin{itemize}
  \item Design of extract/refine operations
\end{itemize}

Extract operation applied on a given abstract value results into message containing refinement information.

Refine operation attempts to improve accuracy of abstract value using refinement information from refinement message.

\section{Integer reduced product}
\begin{itemize}
  \item Walkthrough of Integer domain RP implementation
\end{itemize}

\chapter{\textsc{GNU Core Utilities} analysis}

\chapter{Conclusion}
\section{Impact on program analysis}
\section{Future work}
\begin{itemize}
  \item Pre-condition refinements
  \item Task-parallelism, topological order
\end{itemize}

\bibliographystyle{plain}
\bibliography{reduced_product}

\end{document}