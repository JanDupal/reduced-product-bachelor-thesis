\documentclass[12pt,oneside]{fithesis2}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

% Better font rendering?
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

% Examples
\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]
\newtheorem{definition}{Definition}

% Additional symbols
\usepackage{mathabx}

% Pseudo-code
\usepackage[chapter]{algorithm}
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% URL formatting
\usepackage{url}

% Diagrams
\usepackage{tikz}

% Interactive references
\usepackage{hyperref}

% ToC setup
\usepackage[nottoc,numbib]{tocbibind}
\setcounter{tocdepth}{3}

\thesistitle{Reduced product of abstract domains}
\thesissubtitle{Bachelor thesis}
\thesisstudent{Jan Dupal}
\thesisfaculty{fi}
\thesisyear{spring 2013}
\thesisadvisor{Mgr. Karel Klíč}
\thesislang{en}

\begin{document}
\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
I would like to thank my supervisor...
\end{ThesisThanks}

\begin{ThesisAbstract}
Canal is a static analysis tool designed to analyse behaviour of application programs written in C. It is based on the theoretical framework of abstract interpretation, with focus on the scalability to large programs and proper handling of real-world source code.

Reduced product of abstract domains is a mechanism enabling an incremental evolution of abstract interpreter by introducing simple abstract domains one by one, and supporting program-specific domains. The reduced product itself is an abstract domain, and its operations (transformers) use the transformers of underlying domains component-wise. Underlying domains can improve their precision by exchanging information.

The goal of this thesis is to design and develop a generic reduced product in the context of Canal. The reduced product must provide means to exchange information between the underlying domains while keeping the domains themselves independent from each other. The impact of reduced product of integer intervals, bit field and set abstract domains on the analysis of numeric programs should be measured.
\end{ThesisAbstract}

\begin{ThesisKeyWords}
static analysis, abstract interpretation, reduced product, canal
\end{ThesisKeyWords}

\tableofcontents

\MainMatter
\chapter{Introduction}
\begin{itemize}
  \item program analysis (why?)
  \item static/dynamic
\end{itemize}

Program analysis is a field of Computer Science, which examines behaviour of programs.

\paragraph{Properties of programs}
The behaviour can be described by two distinct properties: \textit{correctness} and \textit{finiteness}.

Intuitively correctness expresses whether the program gives the same results as was intended. Formally...

Finiteness gives guarantee that program will finish it's computation in finite number of steps [citation needed].

\paragraph{Program analysis approaches}
In terms of approach program analysis is divided into two categories: dynamic and static analysis.

As the name suggests \textit{dynamic analysis} is performed on run-time. On the other hand \textit{static analysis} performed without actually executing the program. Obviously both approaches have advantages and disadvantages.

The dynamic analysis is capable of giving very precise results on given program input, where static analysis is input-independent, but it's results are more general, therefore less accurate \cite{CousotEtAl06-ASIAN}.

\section{Static program analysis}
\begin{itemize}
  \item utilization (runtime errors etc.)
  \item cons and pros
\end{itemize}

\section{Abstract interpretation}
\begin{itemize}
  \item basic principles
  \item concrete value - abstract value
\end{itemize}

When manually analysing behaviour of a given program by going through its source code, we often try to enumerate all possible values of a particular program variable. The knowledge of all possible values of the variable allow us to precisely reason about the results of expression incorporating that variable.

To correctly infer results of an expression, depending on cardinality of the expression, we take all possible combinations of input values and apply the expression. The result of our derivation is again a set of all possible values.

However, sometimes (e.g. in case of loops) the set of all possible values might be too large to memorize, so we have to resort to represent the set in another way. One option is to approximate the set as a certain property which is shared among all elements of the set. For example, a set of integers $\{1, 5, 9, 13, 17\}$ can be represented as \textit{odd integers}.

Approach to expressions evaluation is preserved -- first we \textit{concretize} the property representing the set of possible values, then we apply all possible combination of input values, resulting into a set of all possible results, which we \textit{abstract} to a property of the set.

Unconsciously we were using the concepts of \textit{abstract interpretation}.

\section{Reduced product}
\begin{itemize}
  \item References to chapters (theory)
\end{itemize}

\section{Project \textsc{Canal}}
\begin{itemize}
  \item Project goals
  \item References to chapters (implementation)
\end{itemize}


\chapter{Abstract interpretation}\label{ch:abstract-interpretation}
% \begin{itemize}
%   \item Term formalization
%   \item Theoretical frameworks
%   \item False alarms
%   \item Least fixed point
%   \item See Astre
% \end{itemize}

In some cases, a concrete question may not be answered easily. In those cases, we may resort to ask a simpler abstract question that results in an abstract answer.

Using this abstract answer we might be able to answer the original question or at least approximate the concrete answer. \cite{CousotCousot04-WCC}

\section{Usage in static analysis}

Analogous approach has shown as successful in static program analysis, where the concrete question is whether a given program is correct, i.e. the proof of the absence of run-time errors, which is proven to be undecidable \cite{mine-AIAA10}. This problem may be solved using abstraction to soundly approximate the answer. Therefore it is necessary to formalize those abstraction, which is the goal of \textit{abstract interpretation}.

The term abstract interpretation as described in \cite{CousotCousot77-1}:

\begin{quotation}
``A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using this denotation to describe computation in another universe of abstract objects, so that the results of abstract interpretation give some information on the actual computation.''
\end{quotation}

In other words, the goal of program analysis using abstract interpretation is to provide information about program computation. The tool it uses to reach the goal is \textit{abstraction of values and operations}.

\paragraph{Concrete value}
A concrete value stands for a program value. E.g. number 5 is a concrete value.

\paragraph{Abstract value}
An abstract value represents a set of concrete values of a given property (e.g. parity), depending on particular definition. This abstractions allows us to approximate results of concrete executions.

\paragraph{Abstract operations}
To be able to apply operation (e.g. sum of integers) on abstract values, it is necessary to define abstract operations. Abstract operations are used to transform input abstract values to output abstract values. And to be semantically correct, abstract operation must preserve the same behaviour as its concrete model regarding the property used to abstract values.

\vspace{1\baselineskip} % TODO

Given a program and the definitions of abstract values and operations, \textit{abstract interpretation} is able to interpret the program using abstract values instead of concrete values. The result of interpretation is information about properties of program values in each of program steps.


\subsection{Example}\label{sec:example}

To give a brief example of abstract values and operations consider the following computation from \cite{CousotCousot77-1}:

\[ -1515 \cdot 17 \]

To describe this concrete computation as an abstract computation, first we need to define values: symbols $(+)$ and $(-)$ to represent sign of concrete integral value and symbol $(\pm)$ for unknown sign.

Using this abstract values the previous computation corresponds to the following abstract computation:

\[ -(+) \cdot (+) \Rightarrow (-) \cdot (+) \Rightarrow (-) \]

Obviously the result of the first (concrete) computation expressed as abstract value is $(-)$, which is exactly the result of the second (abstract) computation.

\paragraph{Influence of operation}
However using addition instead of multiplication ($-1515 + 17$) leads to inaccurate result of abstract computation:

\[ -(+) + (+) \Rightarrow (-) + (+) \Rightarrow (\pm) \]

As you can see, the sign of the sum of negative and positive integer might be both $+$ or $-$, depending on which component is larger in absolute value. This unknown result is in our abstract universe expressed as $(\pm)$, generally denoted as $\top$.

\paragraph{Influence of abstraction}
Also the choice of abstract values affects accuracy of abstract computation. Choosing abstract values as $\{(even), (odd), \top\}$ to represent parity of integers instead of sign leads to the following results:

\[ -(odd) \cdot (odd) \Rightarrow (odd) \cdot (odd) \Rightarrow (odd) \]
\[ -(odd) + (odd) \Rightarrow (odd) + (odd) \Rightarrow (even) \]

The lack of $\top$ values in the results means that there was no accuracy lost when executing abstract computation.

\section{Theoretical framework}
% \begin{itemize}
%   \item What do abstract values represent?
%   \item Example - $+$, $-$, $\pm$, $|x|$, output
%   \item Abstract domains
%   \item False alarms
% \end{itemize}

This section describes formal requirements necessary to correctly design and implement an abstract interpretation framework including \textit{reduced product}.

\subsection{Domain of abstract values}

As abstract value represents a set of concrete values, so their domains preserve the same relation. \textit{Domain of abstract values} represents a set of all \textit{abstract values} and \textit{domain of concrete values} corresponds to a power set of all concrete values.

For easier comprehension, regard the following definition of \textit{integer interval domain}\cite{mine-WING12}, on which we will demonstrate the usage of defined terms in this chapter.

\textit{Integer interval domain} approximates a set of integers by a pair $[l, h]$, where $l$ and $h$ represents minimal and maximal element of the set, respectively. For example:

\[
  \{ 2, 1, 100, 4 \} \to [1, 100]
\]

As it can be seen, a set of integers $\{2, 1, 100, 4\}$ is represented by integer interval domain as a pair $[1, 100]$. This so called \textit{abstraction function} is later formalized in \ref{ssec:abstraction-function}.

Formal definition of domains used in the \textit{integer interval domain} follows:

\begin{exmp}
  \begin{align*}
    &D = \mathcal P(\mathbb Z)\\
    &D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
  \end{align*}
\end{exmp}

The \textit{domain of concrete values} $D$, in case of integers, is a power set of integers $\mathbb Z$. To remind, a concrete value denotes any program value and their set describes all possible values of a given program value.

And the \textit{domain of abstract values} $D^\#$ is defined to approximate sets of concrete values from $D$. In this case, it is a set of all pairs $[l, h]$, where $l$ and $h$ are integers or symbols representing positive or negative infinity.

This abstraction was chosen, because it belongs to the basic abstractions used in analysis of numerical computation\cite{mine-AIAA10} and its underlying concepts are easy to understand.

By convention, a domain of concrete values will further be denoted as $D$ and a domain of abstract values as $D^\#$ and their elements as $a$ and $C$ respectively.

\subsection{Abstraction function}\label{ssec:abstraction-function}

The correspondence between sets of concrete values and abstract values is established by the \textit{abstraction function}: \cite{CousotCousot76-1}

\[
\alpha_{D^\#}\colon D \to D^\#
\]

The \textit{abstraction function} assigns an abstract value to a given set of concrete values. It belongs to the core concepts of the abstract interpretation, because it provides bridge between a program values and their abstraction -- every program value has to be abstracted before proceeding with abstract interpretation of the program.

To give a particular \textit{abstraction function}, consider the one used in integer interval domain:

\begin{exmp}
  \begin{align*}
    % D = \mathcal P(\mathbb Z)\\
    % D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &\alpha_{D^\#}(C) \triangleq [min(C), max(C)]\\
    &\alpha_{D^\#}(\{-1, 0, 3\}) = [-1, 3]\\
    &\alpha_{D^\#}(\mathbb Z) = [-\infty, \infty]
  \end{align*}
\end{exmp}

As it was outlined in the introduction to this section, the \textit{integer interval domain} represents sets of concrete values as a pair of minimal and maximal element -- the bounds of the interval.

The example demonstrates application of \textit{abstraction function} $\alpha_{D^\#}$ on a small set of integers, which is rather obvious. And the second application shows interval $[-\infty, \infty]$ corresponding to the set of all integers, $\mathbb Z$.

Note that this particular abstraction may include in the approximation some excessive concrete values due to its definition utilizing only minimal and maximal element -- this property of abstraction is denoted as \textit{incompleteness} and will be defined later in \ref{ssec:soundness-incompleteness}.

\subsection{Concretization function}
Dually to abstraction function, \textit{concretization function} transforms an abstract value into a set of concrete values, which are represented by the given abstract value.

Importance of this function lies in the fact, that it defines a concrete semantics of abstract values -- it enables us to translate results of abstract interpretation into the universe of abstract values. And last but not least, together with abstract functions, it defines almost all subsequent terms of abstract interpretation.

A \textit{concretization function} is a function of type:

\[
\gamma_{D^\#}\colon D^\# \to D
\]

One example is the concretization function of the \textit{integer interval domain}:

\begin{exmp}
  \begin{align*}
    % D = \mathcal P(\mathbb Z)\\
    % D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &\gamma_{D^\#}([l,h]) \triangleq \{x \in \mathbb Z | l \le x \le h\}\\
    &\gamma_{D^\#}([-1,3]) = \{-1, 0, 1, 2, 3\}\\
    &\gamma_{D^\#}([-\infty, \infty]) = \mathbb Z
  \end{align*}
\end{exmp}

Concretization function of the integer interval domain converts an interval into a set of all integers lying between the bounds of the interval, including the bounds.

As you can see, this concretization function does not omit any of the concrete values inside the interval, thanks of the definition, which over-approximates the set of concrete values, thus giving guarantee on \textit{soundness} -- this property is formalized in \ref{ssec:soundness-incompleteness}.

\subsection{Partial order of abstract and concrete values}

As the domain of abstract values is defines as a power set, it can be partially ordered by set inclusion $\subseteq$. This property is interesting to abstract interpretation, because it allows to compare sets of abstract values in the sense of ``is included in'', which is a useful feature e.g. when computing a fixed point of a given loop in a program.

Dually we define partial order on the domain of abstract values via $\sqsubseteq$ expressing so called ``information pre-order''. Again, this relation enables us to compare abstract values and e.g. compute abstract fix point of a loop or a program.

Generally the $\sqsubseteq$ is defined as follows:

\begin{definition}
  Let $A_1, A_2 \in D^\#$, then
  \[
    A_1 \sqsubseteq A_2 \triangleq \gamma_{D^\#}(A_1) \subseteq \gamma_{D^\#}(A_2)
  \]
\end{definition}


The following demonstration shows a link between $\subseteq$ and $\sqsubseteq$ defined in the integer interval domain:

\begin{exmp}
  \begin{align*}
    \emptyset \subseteq \{1\} &\subseteq \{0, 1, 2\} \subseteq \mathbb Z\\
    [1,0] \sqsubseteq [1,1] &\sqsubseteq [0,2] \sqsubseteq [-\infty,\infty]
  \end{align*}
\end{exmp}

As it can be seen, if the sets of concrete values does not omit any value between minimal and maximal elements, operators $\subseteq$ and $\sqsubseteq$ correspond precisely. However observe the following example:

\begin{exmp}
  \begin{align*}
    \{1, 5\} \subseteq \{0, 1, 3, 5, 7\} &\Rightarrow [1,5] \sqsubseteq [0,7]\\
    \{ 4, 5\} \not\subseteq \{0, 7\} &\not\Rightarrow [4,5] \not\sqsubseteq [0,7]\\
  \end{align*}
\end{exmp}

The last example has demonstrated the consequences of being \textit{incomplete} approximation. However the property of \textit{soudness} guarantees that... %TODO

\subsection{Soundness and incompleteness of approximation}\label{ssec:soundness-incompleteness}

\paragraph{Soundness}
In order to be sound approximation, abstraction and concretization functions has to satisfy the following requirement: \cite{mine-AIAA10}

\[
  \forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

Intuitively soundness means, that no concrete value is omitted by abstraction. In context of program analysis, soundness expresses \textit{the lack of false negatives}, which is often required property.

\paragraph{Completeness}
In opposite to soundness, \textit{completeness} is not required by abstract interpretation. But its presence is very valuable. It is defined as: \cite{mine-AIAA10}

\[
  \forall C \in D: C \supseteq \gamma_{D^\#}(\alpha_{D^\#}(C))
\]

Completeness corresponds in terms of static analysis to \textit{the absence of false positives}.

\subsection{Galois connection}

To set an upper bound on a ``best'' possible abstraction\cite{mine-AIAA10}, \textit{Galois connection}  between posets $(D, \subseteq)$ and $(D_\#, \sqsubseteq)$ is defined via a pair of adjoined functions $\langle \alpha_{D^\#}, \gamma_{D^\#} \rangle$ as followed: \cite{CousotCousot79-1}

\begin{enumerate}
  \item $\alpha_{D^\#}$ and $\alpha_{D^\#}$ are \textit{isotone}
  \item $\forall C \in D: C \subseteq \gamma_{D^\#}(\alpha_{D^\#}(C))$
  \item $\forall a \in D^\#: a \subseteq \alpha_{D^\#}(\gamma_{D^\#}(a))$
\end{enumerate}

Intuitively, the presence of \textit{Galois connection} ensures that any concrete value $T \in D$ has a ``best'' approximation $\alpha_{D^\#}(T)$, that over-approximates $T$ as $T \subseteq \gamma_{D^\#}(\alpha_{D^\#}(T))$. And given any other over-approximation $R \in D^\#$, so $T \subseteq \gamma_{D^\#}(R)$, then $\alpha_{D^\#}(T)$ is more precise, because $\alpha_{D^\#}(T) \sqsubseteq R$.

Galois connection also allows us to define \textit{soundness} and \textit{completeness} dually. Moreover, it also defines \textit{abstract operation} in a precise way as shown in \ref{sec:operations}.

However, the presence of Galois connection might not always be possible or feasible.

\subsection{Lattices of abstract values}

\begin{figure}[ht!]
  \centering
  \begin {tikzpicture}[node distance=1.5cm]
    \node (Top) { $\top$ };
    \node (Positive) [below left of=Top] { $(+)$ };
    \node (Negative) [below right of=Top] { $(-)$ };
    \node (Zero) [below right of=Positive] { $0$ };
    \node (Bottom) [below of=Zero] { $\bot$ };
    \draw (Top) -- (Positive);
    \draw (Top) -- (Negative);
    \draw (Positive) -- (Zero);
    \draw (Negative) -- (Zero);
    \draw (Zero) -- (Bottom);
  \end {tikzpicture}
  \caption{Sign lattice}
\end{figure}

\begin{figure}[ht!]
  \centering
  \begin {tikzpicture}[node distance=1.5cm]
    \node (Top) { $\top$ };
    \node (Even) [below left of=Top] { $ev$ };
    \node (Odd) [below right of=Top] { $od$ };
    \node (Bottom) [below right of=Even] { $\bot$ };
    \draw (Top) -- (Even);
    \draw (Top) -- (Odd);
    \draw (Even) -- (Bottom);
    \draw (Odd) -- (Bottom);
  \end {tikzpicture}
  \caption{Parity lattice}
\end{figure}

\subsection{Abstract operations}\label{sec:operations}

As stated in the introduction, abstract operation (sometimes referred as \textit{abstract transformers}) enable to approximate results of transformations defined in programs. To preserve soundness of abstract interpretation, abstract operations also has to be \textit{sound approximation}:

\begin{definition}
For any concrete $n$-ary primitive $F: D^n \to D$, in case of Galois connection a ``best'' possible abstraction $F_{D^\#}$ is defined: \cite{mine-AIAA10}

\[
  F_{D^\#} \triangleq \alpha_{D^\#} \circ F \circ \gamma_{D^\#}
\]

Otherwise, $F_{D^\#}$ over-approximates $F$. Therefore, we require $F_{D^\#}$ to be a sound abstraction: \cite{CousotEtAl06-ASIAN}

\[
\forall a_i \in D^\#: F_{D^\#}((\gamma_{D^\#}(a_i))_{1 \le i \le n}) \subseteq \gamma_{D^\#}(F((a_i)_{1 \le i \le n}))
\]

\end{definition}

\begin{exmp}[Addition, Integer Interval Domain\cite{mine-WING12}]
  \begin{align*}
    &D = \mathcal P(\mathbb Z)\\
    &D^\# = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &F: D \times D \to D\\
    &F(A,B) \triangleq \{a+b | a \in A, b \in B \}\\
    &F_{D^\#}: D^\# \times D^\# \to D^\#\\
    &F_{D^\#}([l_1, h_1], [l_2, h_2]) \triangleq [l_1 + l_2, h_1 + h_2]\\
    &F(\{1,2,3\}, \{0,10\}) = \{1,2,3,11,12,13\}\\
    &F_{D^\#}([1,3], [0,10]) = [1,13]
  \end{align*}
\end{exmp}

\chapter{Reduced product}

As demonstrated in Example in section \ref{sec:example}, a single abstract domain may not be able to accurately cover all possible abstract operations. Therefore it is convenient to incorporate \textit{multiple specialized abstract domains}. Each of these domains may capture a specific property of concrete value while ignoring other [citation].

When designing a new abstract domain, this approach allows us to focus on the core functionality of the domain and does not burden us with necessity of implementing all possible abstract operations in accurate manner, which may not be possible or feasible. But it ultimately leads to the need for inter-domain accuracy refinements.

This chapter establishes \textit{domain product} in section \ref{sec:domain-product}, which is later in section \ref{sec:reduced-cardinality-product} extended into \textit{reduced cardinality product} using appropriate \textit{reduction} defined in section \ref{sec:reductions}.

The chapter is concluded by a proposal of implementation in section \ref{sec:proposal-of-implementation}.

% From high-level view the goal of the communication framework is to encapsulate and refine abstract domains representing a single program variable, hence it can be viewed as a \textit{reduced product of abstract domains}.

% Reduced product of abstract domains consist of the following components:

% \begin{description}
%   \item[Domain product] encapsulates multiple abstract values
%   \item[Communication protocol] enables inter-domain communication
%   \item[Internal structure] defines process of refinement
% \end{description}

\section{Domain product}\label{sec:domain-product}
% \begin{itemize}
%   \item Definition
%   \item Multiple representations of concrete value
% \end{itemize}

Motivation to introduce \textit{domain product} to abstract interpretation has been outlined in the beginning of this chapter - using a single abstract value to represent a program value would lead either to inaccurate results or complex implementation. Also it would not allow to deploy a new abstract domain tailored for a specific problem. \cite{CousotEtAl06-ASIAN}

To circumvent this obstacle, it is convenient to introduce a \textit{domain product}, which acts as encapsulation of abstract values representing the same program variable. From an external perspective, the domain products performs as a standalone abstract domain.

\textit{Domain product} is defined as follows \cite{CousotCousotMauborgne-FoSSaCS-11}:

\begin{definition}
  Let $\langle D^\#_i, \sqsubseteq_i \rangle$, $i \in I$, $I$ finite, be abstract domains. Their Cartesian product is $\langle D^\#, \sqsubseteq \rangle$, where:
  \begin{align*}
    &D^\# \triangleq \bigtimes_{i \in I} D^\#_i\\
    &P \sqsubseteq Q \triangleq \bigwedge_{i \in I}\left(P_i \sqsubseteq_i Q_i \right)\\
    &\gamma_{D^\#}: \bigtimes_{i \in I} D^\#_i \to D\\
    &\gamma_{D^\#}(P) \triangleq \bigcap_{i \in I} \gamma_{D^\#_i}\left( P_i \right)
  \end{align*}
\end{definition}

To approach the definition, consider the following example.

\begin{exmp}
  \begin{align*}
    &D = D_1 = D_2 = \mathcal P(\mathbb Z)\\
    &D^\#_1 = \{[l,h] | l,h \in \mathbb{Z} \cup \{\pm\infty\}\}\\
    &D^\#_2 = \{\bot, ev, od, \top\}\\
    &D^\# = D^\#_1 \times D^\#_2\\
    &\alpha_{D^\#}(\{1,3,7\}) = \left( [1,7], od \right)\\
    &\gamma_{D^\#}(\left( [1, 7], od \right)) = \{1,3,5,7\}
  \end{align*}

  By the definition, $\left( [1, 7], od \right) \sqsubseteq \left( [0, 7], \top \right)$, however $\left( [1, 7], od \right) \not\sqsubseteq \left( [1, 7], ev \right)$.
\end{exmp}

As it may seem that $\gamma_{D^\#}$ provides the key to refinement of abstract values, we have to keep in mind that abstract functions are still applied component-wise. Therefore we get the same results as in case of \textit{separate analyses}, as stated in \cite{CousotCousot79-1}.

\section{Reduced product}\label{sec:reduced-cardinality-product}

As \textit{domain product} contains multiple abstract domains, each covering different aspect of concrete value, we may increase accuracy of contained domains by exploiting inter-domain refinements.

Intuitively, if one of the domains has inaccurately approximated a result of some concrete operation, while other domain was able to give an accurate abstraction, it would be convenient to enhance accuracy of the first domain using information provided by the second domain. Obviously the degree of improvement depends on the difference in the nature of abstraction used by domains.

\paragraph{Soundness} To preserve soundness of analysis, a reduction of domain product has to keep its semantics -- a concrete value it represents has to remain unchanged.

\textit{Reduced product} is defined in the following way: \cite{CousotCousotMauborgne-FoSSaCS-11}

\begin{definition}
  Let $\langle D^\#, \sqsubseteq \rangle$ be a \textit{domain product} with concretization function $\gamma_{D^\#}$.

  Then \textit{reduced product} is $\langle D^\# /_\equiv, \sqsubseteq \rangle$, where equivalence is defined as  $\left(P \equiv Q \right) \triangleq \left(\gamma_{D^\#}(P) = \gamma_{D^\#}(Q) \right)$ and $\gamma_{D^\#}$ as well as $\sqsubseteq$ are naturally extended to the equivalence class $[P]/_\equiv$, $P \in D^\#$, of $\equiv$.
\end{definition}

\section{Approximations of reduction}\label{sec:reductions}

\section{Proposal of implementation}\label{sec:proposal-of-implementation}

\subsection{Communication protocol}
\begin{itemize}
  \item Types of communication (direct, broadcast)
  \item Description of message
  \item Properties of message (lattice)
  % \item Extract
  % \item Refine
\end{itemize}

\subsection{Extract operation}

Extract operation applied on a given abstract value results into message containing refinement information.

\subsection{Refine operation}

Refine operation attempts to improve accuracy of abstract value using refinement information from refinement message.

\subsection{Internal structure}
\begin{itemize}
  \item Plain and Tree
  \item Traversing algorithms
  \item Expected impact on accuracy and performance
  \item Correctness, convergence, complexity
\end{itemize}


\chapter{Implementation in \textsc{Canal}}
% \begin{itemize}
%   \item Overview of Canal
%   \item Overview of RP implementation
% \end{itemize}

This chapter addresses \textsc{Canal} project and its implementation of \textit{reduced product}.

\section{Introduction to \textsc{Canal} project}

\textsc{Canal} is a static analysis tool designed to analyze behaviour of
application programs written in C [language]. It is based on the theoretical
framework of abstract interpretation, with focus on the scalability to
large programs and proper handling of real-world source code. \cite{Canal}

It consists of three main components:

\begin{description}
  \item[Abstract domains] set of predefined abstract domains to cover machine integers, floating point numbers, arrays and structures
  \item[Interpreter] component responsible for source code traversal and program state management
  \item[Operations] translation from program instructions to operations on abstract values
\end{description}

Components \textit{abstract domains} and \textit{operations} correspond to entities described in chapter \ref{ch:abstract-interpretation}. \textit{Interpreter} involves concept of \textit{least fixed point} (section \ref{sec:fixed-point}) and it is interesting from technical point of view, because it incorporates LLVM libraries for interaction with source code.

LLVM is a a compiler framework, which provides a combination of key capabilities that are important for practical, lifelong analysis and
transformation of programs. \cite{llvm} It isolates \textsc{Canal} from machine-level semantics of C language and allows to offload processes associated with compiling and instruction-level analysis, therefore development of \textsc{Canal} can fully focus on abstract interpretation.

Provided the previous components, \textsc{Canal} is able to statically analyze general programs written in C. The high-level work flow can be described in the following way:

\begin{enumerate}
  \item Compilation of program source utilising LLVM compiler
  \item Load of resulting LLVM bytecode
  \item Initialization of program state using abstract values
  \item Translation of program instructions to abstract operations
  \item Execution of abstract operations on abstract values
\end{enumerate}

\section{Framework of reduced product in \textsc{Canal}}

\subsection{Containers}
\begin{itemize}
  \item Vector, Tree
  \item Cons and pros
\end{itemize}

\subsection{Messages}
\begin{itemize}
  \item Kind of messages
  \item Meet
\end{itemize}

\subsection{Extract and Refine operations}
\begin{itemize}
  \item Design of extract/refine operations
\end{itemize}

\section{Integer reduced product}
\begin{itemize}
  \item Walkthrough of Integer domain RP implementation
\end{itemize}

\chapter{\textsc{GNU Core Utilities} analysis}

\chapter{Conclusion}
\section{Impact on program analysis}
\section{Future work}
\begin{itemize}
  \item Pre-condition refinements
  \item Task-parallelism, topological order
\end{itemize}

\bibliographystyle{plain}
\bibliography{reduced_product}

\end{document}